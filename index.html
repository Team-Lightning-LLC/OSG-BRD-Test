<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>·</title>
  <link rel="icon" type="image/svg+xml" href="data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 32 32'%3E%3Ccircle cx='16' cy='16' r='3' fill='%23555'/%3E%3C/svg%3E">
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=Crimson+Pro:ital,wght@0,300;0,400;1,300&display=swap" rel="stylesheet">
  <script src="https://cdn.jsdelivr.net/npm/marked/marked.min.js"></script>
  <style>
    * { margin: 0; padding: 0; box-sizing: border-box; }
    
    html, body {
      height: 100%;
      overflow: hidden;
      background: #000;
      font-family: 'Crimson Pro', Georgia, serif;
      color: rgba(255,255,255,0.8);
    }
    
    canvas {
      position: fixed;
      top: 0;
      left: 0;
      cursor: none;
    }
    
    /* Crosshair */
    #crosshair {
      position: fixed;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      pointer-events: none;
      z-index: 100;
    }
    
    .crosshair-ring {
      width: 40px;
      height: 40px;
      border: 1px solid rgba(255,255,255,0.15);
      border-radius: 50%;
      transition: all 0.3s cubic-bezier(0.16, 1, 0.3, 1);
    }
    
    .crosshair-ring::before {
      content: '';
      position: absolute;
      top: 50%;
      left: 50%;
      width: 4px;
      height: 4px;
      background: rgba(255,255,255,0.4);
      border-radius: 50%;
      transform: translate(-50%, -50%);
    }
    
    body.targeting .crosshair-ring {
      width: 60px;
      height: 60px;
      border-color: rgba(120, 180, 180, 0.5);
    }
    
    body.diving .crosshair-ring {
      width: 200px;
      height: 200px;
      border-color: rgba(120, 180, 180, 0.3);
      animation: diveRing 1s ease-out forwards;
    }
    
    @keyframes diveRing {
      to {
        width: 400px;
        height: 400px;
        opacity: 0;
      }
    }
    
    /* HUD */
    #hud {
      position: fixed;
      bottom: 32px;
      left: 50%;
      transform: translateX(-50%);
      text-align: center;
      z-index: 100;
      pointer-events: none;
    }
    
    #location {
      font-size: 11px;
      letter-spacing: 0.2em;
      text-transform: uppercase;
      color: rgba(255,255,255,0.25);
      margin-bottom: 8px;
      transition: opacity 0.5s ease;
    }
    
    #target {
      font-size: 15px;
      font-style: italic;
      color: rgba(255,255,255,0.5);
      opacity: 0;
      transform: translateY(10px);
      transition: all 0.3s ease;
    }
    
    #target.visible {
      opacity: 1;
      transform: translateY(0);
    }
    
    #depth {
      position: fixed;
      top: 32px;
      left: 50%;
      transform: translateX(-50%);
      display: flex;
      align-items: center;
      gap: 16px;
      z-index: 100;
    }
    
    .depth-crumb {
      font-size: 11px;
      letter-spacing: 0.1em;
      color: rgba(255,255,255,0.2);
      cursor: pointer;
      pointer-events: all;
      transition: color 0.2s ease;
    }
    
    .depth-crumb:hover {
      color: rgba(255,255,255,0.5);
    }
    
    .depth-crumb.current {
      color: rgba(255,255,255,0.4);
    }
    
    .depth-separator {
      font-size: 10px;
      color: rgba(255,255,255,0.1);
    }
    
    /* Document viewer */
    #viewer {
      position: fixed;
      inset: 0;
      background: rgba(0,0,0,0.95);
      z-index: 200;
      display: flex;
      align-items: center;
      justify-content: center;
      opacity: 0;
      pointer-events: none;
      transition: opacity 0.5s ease;
    }
    
    #viewer.open {
      opacity: 1;
      pointer-events: all;
    }
    
    .viewer-content {
      max-width: 640px;
      max-height: 80vh;
      padding: 48px;
      overflow-y: auto;
      opacity: 0;
      transform: scale(0.95);
      transition: all 0.5s cubic-bezier(0.16, 1, 0.3, 1) 0.1s;
    }
    
    #viewer.open .viewer-content {
      opacity: 1;
      transform: scale(1);
    }
    
    .viewer-content::-webkit-scrollbar { width: 2px; }
    .viewer-content::-webkit-scrollbar-thumb { background: rgba(255,255,255,0.1); }
    
    .viewer-content h1 {
      font-size: 26px;
      font-weight: 300;
      margin-bottom: 32px;
      padding-bottom: 16px;
      border-bottom: 1px solid rgba(255,255,255,0.1);
    }
    
    .viewer-content h2 {
      font-size: 18px;
      font-weight: 400;
      margin: 28px 0 14px;
      color: rgba(255,255,255,0.7);
    }
    
    .viewer-content p {
      font-size: 16px;
      line-height: 1.9;
      color: rgba(255,255,255,0.6);
      margin-bottom: 14px;
    }
    
    .viewer-content ul, .viewer-content ol {
      margin: 14px 0;
      padding-left: 20px;
    }
    
    .viewer-content li {
      font-size: 16px;
      line-height: 1.8;
      color: rgba(255,255,255,0.6);
      margin-bottom: 6px;
    }
    
    .viewer-content table {
      width: 100%;
      border-collapse: collapse;
      margin: 20px 0;
    }
    
    .viewer-content th {
      font-size: 10px;
      font-weight: 400;
      letter-spacing: 0.1em;
      text-transform: uppercase;
      color: rgba(255,255,255,0.3);
      padding: 10px 12px;
      text-align: left;
      border-bottom: 1px solid rgba(255,255,255,0.1);
    }
    
    .viewer-content td {
      font-size: 13px;
      padding: 10px 12px;
      color: rgba(255,255,255,0.5);
      border-bottom: 1px solid rgba(255,255,255,0.05);
    }
    
    .viewer-content .status-complete { color: rgba(120, 200, 150, 0.9); }
    .viewer-content .status-incomplete { color: rgba(200, 150, 120, 0.9); }
    
    .viewer-hint {
      position: fixed;
      bottom: 32px;
      left: 50%;
      transform: translateX(-50%);
      font-size: 12px;
      font-style: italic;
      color: rgba(255,255,255,0.2);
    }
    
    /* Messages */
    #message {
      position: fixed;
      bottom: 80px;
      left: 50%;
      transform: translateX(-50%);
      font-size: 13px;
      font-style: italic;
      color: rgba(255,255,255,0.3);
      z-index: 150;
      opacity: 0;
      transition: opacity 0.4s ease;
      pointer-events: none;
    }
    
    #message.visible { opacity: 1; }
    
    /* Loading */
    #loading {
      position: fixed;
      inset: 0;
      background: #000;
      display: flex;
      align-items: center;
      justify-content: center;
      z-index: 500;
      transition: opacity 1s ease;
    }
    
    #loading.hidden {
      opacity: 0;
      pointer-events: none;
    }
    
    .loading-dot {
      width: 6px;
      height: 6px;
      background: rgba(255,255,255,0.4);
      border-radius: 50%;
      animation: pulse 2s ease infinite;
    }
    
    @keyframes pulse {
      0%, 100% { opacity: 0.2; transform: scale(1); }
      50% { opacity: 0.8; transform: scale(1.3); }
    }
    
    /* Invoke */
    #invoke {
      position: fixed;
      bottom: 100px;
      left: 50%;
      transform: translateX(-50%);
      z-index: 150;
      opacity: 0;
      pointer-events: none;
      transition: opacity 0.3s ease;
    }
    
    #invoke.active {
      opacity: 1;
      pointer-events: all;
    }
    
    #invoke input {
      width: 300px;
      padding: 14px 24px;
      background: rgba(255,255,255,0.03);
      border: 1px solid rgba(255,255,255,0.1);
      border-radius: 24px;
      font-family: inherit;
      font-size: 15px;
      font-style: italic;
      color: rgba(255,255,255,0.8);
      text-align: center;
      outline: none;
    }
    
    #invoke input::placeholder {
      color: rgba(255,255,255,0.25);
    }
    
    /* Drop */
    body.dropping::after {
      content: 'release to offer';
      position: fixed;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      font-size: 16px;
      font-style: italic;
      color: rgba(120, 180, 180, 0.6);
      z-index: 300;
    }
    
    body.dropping::before {
      content: '';
      position: fixed;
      inset: 0;
      background: radial-gradient(circle at center, rgba(120, 180, 180, 0.08) 0%, transparent 50%);
      z-index: 299;
      pointer-events: none;
    }
    
    input[type="file"] { display: none; }
  </style>
</head>
<body>
  <div id="loading"><div class="loading-dot"></div></div>
  
  <canvas id="canvas"></canvas>
  
  <div id="crosshair"><div class="crosshair-ring"></div></div>
  
  <div id="depth"></div>
  
  <div id="hud">
    <div id="location">the field</div>
    <div id="target"></div>
  </div>
  
  <div id="invoke">
    <input type="text" id="invokeInput" placeholder="speak" autocomplete="off">
  </div>
  
  <div id="viewer">
    <div class="viewer-content" id="viewerContent"></div>
    <div class="viewer-hint">click anywhere to return</div>
  </div>
  
  <div id="message"></div>
  <input type="file" id="fileInput" multiple>

<script>
const CONFIG = {
  API_BASE: 'https://api.vertesia.io/api/v1',
  AUTH_BASE: 'https://api.vertesia.io',
  API_KEY: 'sk-cf3c2d29bc38bfee2ae95bf107cb9046',
  INTERACTION: 'PathB'
};

// === CAMERA ===
const camera = {
  x: 0,
  y: 0,
  z: -800,  // Distance from origin (negative = behind)
  targetX: 0,
  targetY: 0,
  targetZ: -800,
  fov: 400,
  
  lerp(t) {
    this.x += (this.targetX - this.x) * t;
    this.y += (this.targetY - this.y) * t;
    this.z += (this.targetZ - this.z) * t;
  },
  
  project(x, y, z) {
    // Translate relative to camera
    const dx = x - this.x;
    const dy = y - this.y;
    const dz = z - this.z;
    
    // Don't render things behind camera
    if (dz <= 0) return null;
    
    // Perspective projection
    const scale = this.fov / dz;
    const screenX = window.innerWidth / 2 + dx * scale;
    const screenY = window.innerHeight / 2 + dy * scale;
    
    return { x: screenX, y: screenY, scale, depth: dz };
  }
};

// === SPACE (nested universes) ===
class Space {
  constructor(id, name, parent = null) {
    this.id = id;
    this.name = name;
    this.parent = parent;
    this.bodies = [];
    this.center = { x: 0, y: 0, z: 0 };
  }
  
  addBody(body) {
    body.space = this;
    this.bodies.push(body);
  }
}

// === CELESTIAL BODY (collections = black holes, documents = stars) ===
class Body {
  constructor(data, type) {
    this.id = data.id;
    this.name = data.name || 'Untitled';
    this.type = type; // 'singularity' (collection) or 'star' (document)
    this.data = data;
    this.space = null;
    
    // 3D position
    this.x = (Math.random() - 0.5) * 600;
    this.y = (Math.random() - 0.5) * 400;
    this.z = (Math.random() - 0.5) * 400;
    
    // Orbital motion
    this.orbitRadius = 0;
    this.orbitAngle = Math.random() * Math.PI * 2;
    this.orbitSpeed = 0.0002 + Math.random() * 0.0003;
    this.orbitTilt = (Math.random() - 0.5) * 0.5;
    
    // Visual
    if (type === 'singularity') {
      this.baseRadius = 20;
      this.hue = 200;
      this.sat = 60;
      this.hasAccretionDisk = true;
      this.innerSpace = null; // Will hold the space inside this collection
    } else {
      this.baseRadius = 4 + Math.random() * 4;
      this.hue = 30 + Math.random() * 30;
      this.sat = 20 + Math.random() * 20;
      this.hasAccretionDisk = false;
    }
    
    this.radius = this.baseRadius;
    this.alpha = 0.8;
    this.phase = Math.random() * Math.PI * 2;
  }
  
  setOrbit(centerX, centerY, centerZ, radius) {
    this.orbitCenterX = centerX;
    this.orbitCenterY = centerY;
    this.orbitCenterZ = centerZ;
    this.orbitRadius = radius;
  }
  
  update(time, dt) {
    // Orbital motion
    if (this.orbitRadius > 0) {
      this.orbitAngle += this.orbitSpeed * dt;
      this.x = this.orbitCenterX + Math.cos(this.orbitAngle) * this.orbitRadius;
      this.y = this.orbitCenterY + Math.sin(this.orbitAngle) * this.orbitRadius * this.orbitTilt;
      this.z = this.orbitCenterZ + Math.sin(this.orbitAngle) * this.orbitRadius * 0.3;
    }
    
    // Gentle pulsing
    const pulse = Math.sin(time * 0.001 + this.phase) * 0.1;
    this.radius = this.baseRadius * (1 + pulse);
  }
  
  draw(ctx, proj) {
    if (!proj) return;
    
    const { x, y, scale, depth } = proj;
    const r = this.radius * scale;
    
    // Skip if too small or off screen
    if (r < 0.5) return;
    if (x < -100 || x > window.innerWidth + 100) return;
    if (y < -100 || y > window.innerHeight + 100) return;
    
    // Depth-based alpha
    const depthAlpha = Math.min(1, Math.max(0.1, 1 - depth / 2000));
    const alpha = this.alpha * depthAlpha;
    
    if (this.type === 'singularity') {
      // === BLACK HOLE ===
      
      // Event horizon (dark core)
      ctx.fillStyle = `rgba(0, 0, 0, ${alpha})`;
      ctx.beginPath();
      ctx.arc(x, y, r, 0, Math.PI * 2);
      ctx.fill();
      
      // Photon sphere (bright ring)
      ctx.strokeStyle = `hsla(${this.hue}, ${this.sat}%, 70%, ${alpha * 0.8})`;
      ctx.lineWidth = Math.max(1, r * 0.15);
      ctx.beginPath();
      ctx.arc(x, y, r * 1.2, 0, Math.PI * 2);
      ctx.stroke();
      
      // Accretion disk
      if (this.hasAccretionDisk && r > 5) {
        ctx.save();
        ctx.translate(x, y);
        
        // Elliptical disk
        for (let i = 3; i > 0; i--) {
          const diskRadius = r * (2 + i * 0.8);
          const gradient = ctx.createRadialGradient(0, 0, r, 0, 0, diskRadius);
          gradient.addColorStop(0, `hsla(${this.hue + 20}, ${this.sat}%, 60%, ${alpha * 0.4 / i})`);
          gradient.addColorStop(0.5, `hsla(${this.hue}, ${this.sat}%, 50%, ${alpha * 0.2 / i})`);
          gradient.addColorStop(1, 'transparent');
          
          ctx.fillStyle = gradient;
          ctx.beginPath();
          ctx.ellipse(0, 0, diskRadius, diskRadius * 0.3, 0, 0, Math.PI * 2);
          ctx.fill();
        }
        
        ctx.restore();
      }
      
      // Inner glow
      const innerGlow = ctx.createRadialGradient(x, y, 0, x, y, r * 0.8);
      innerGlow.addColorStop(0, `hsla(${this.hue}, ${this.sat}%, 80%, ${alpha * 0.3})`);
      innerGlow.addColorStop(1, 'transparent');
      ctx.fillStyle = innerGlow;
      ctx.beginPath();
      ctx.arc(x, y, r * 0.8, 0, Math.PI * 2);
      ctx.fill();
      
    } else {
      // === STAR ===
      
      // Glow
      const glow = ctx.createRadialGradient(x, y, 0, x, y, r * 4);
      glow.addColorStop(0, `hsla(${this.hue}, ${this.sat}%, 80%, ${alpha * 0.6})`);
      glow.addColorStop(0.3, `hsla(${this.hue}, ${this.sat}%, 60%, ${alpha * 0.2})`);
      glow.addColorStop(1, 'transparent');
      ctx.fillStyle = glow;
      ctx.beginPath();
      ctx.arc(x, y, r * 4, 0, Math.PI * 2);
      ctx.fill();
      
      // Core
      ctx.fillStyle = `hsla(${this.hue}, ${this.sat - 10}%, 90%, ${alpha})`;
      ctx.beginPath();
      ctx.arc(x, y, r, 0, Math.PI * 2);
      ctx.fill();
    }
  }
  
  hitTest(screenX, screenY, proj) {
    if (!proj) return false;
    const dx = screenX - proj.x;
    const dy = screenY - proj.y;
    const hitRadius = Math.max(30, this.radius * proj.scale * 2);
    return (dx * dx + dy * dy) < hitRadius * hitRadius;
  }
}

// === STATE ===
let spaces = [];
let currentSpace = null;
let collections = [];
let documents = [];
let collectionMembers = {};
let targetedBody = null;
let isDiving = false;
let isInvoking = false;
let viewerOpen = false;
let navigationStack = []; // Breadcrumb trail

// === CANVAS ===
const canvas = document.getElementById('canvas');
const ctx = canvas.getContext('2d');

function resize() {
  canvas.width = window.innerWidth;
  canvas.height = window.innerHeight;
}
window.addEventListener('resize', resize);
resize();

// === ANIMATION ===
let lastTime = performance.now();

function animate(now) {
  const dt = now - lastTime;
  lastTime = now;
  
  // Clear
  ctx.fillStyle = '#000';
  ctx.fillRect(0, 0, canvas.width, canvas.height);
  
  // Update camera
  const cameraSpeed = isDiving ? 0.03 : 0.08;
  camera.lerp(cameraSpeed);
  
  if (!currentSpace) {
    requestAnimationFrame(animate);
    return;
  }
  
  // Draw distant stars (background)
  drawStarfield(ctx, now);
  
  // Sort bodies by depth for painter's algorithm
  const sortedBodies = [...currentSpace.bodies].sort((a, b) => {
    const projA = camera.project(a.x, a.y, a.z);
    const projB = camera.project(b.x, b.y, b.z);
    if (!projA) return 1;
    if (!projB) return -1;
    return projB.depth - projA.depth;
  });
  
  // Update and draw bodies
  sortedBodies.forEach(body => {
    body.update(now, dt);
    const proj = camera.project(body.x, body.y, body.z);
    body.draw(ctx, proj);
  });
  
  // Check targeting (what's at screen center)
  updateTargeting();
  
  requestAnimationFrame(animate);
}

function drawStarfield(ctx, time) {
  // Distant background stars
  const seed = 12345;
  for (let i = 0; i < 200; i++) {
    const rand = mulberry32(seed + i);
    const x = rand() * canvas.width;
    const y = rand() * canvas.height;
    const size = rand() * 1.5;
    const twinkle = Math.sin(time * 0.001 * (rand() + 0.5) + rand() * 10) * 0.3 + 0.7;
    
    ctx.fillStyle = `rgba(255, 255, 255, ${0.3 * twinkle})`;
    ctx.beginPath();
    ctx.arc(x, y, size, 0, Math.PI * 2);
    ctx.fill();
  }
}

function mulberry32(a) {
  return function() {
    var t = a += 0x6D2B79F5;
    t = Math.imul(t ^ t >>> 15, t | 1);
    t ^= t + Math.imul(t ^ t >>> 7, t | 61);
    return ((t ^ t >>> 14) >>> 0) / 4294967296;
  }
}

function updateTargeting() {
  if (isDiving || viewerOpen) return;
  
  const centerX = window.innerWidth / 2;
  const centerY = window.innerHeight / 2;
  
  let closest = null;
  let closestDist = Infinity;
  
  currentSpace.bodies.forEach(body => {
    const proj = camera.project(body.x, body.y, body.z);
    if (!proj) return;
    
    const dx = proj.x - centerX;
    const dy = proj.y - centerY;
    const dist = Math.sqrt(dx * dx + dy * dy);
    const hitRadius = Math.max(40, body.radius * proj.scale * 1.5);
    
    if (dist < hitRadius && dist < closestDist) {
      closest = body;
      closestDist = dist;
    }
  });
  
  if (closest !== targetedBody) {
    targetedBody = closest;
    updateTargetDisplay();
  }
}

function updateTargetDisplay() {
  const targetEl = document.getElementById('target');
  
  if (targetedBody) {
    document.body.classList.add('targeting');
    targetEl.textContent = targetedBody.name;
    targetEl.classList.add('visible');
  } else {
    document.body.classList.remove('targeting');
    targetEl.classList.remove('visible');
  }
}

// === NAVIGATION ===
function diveInto(body) {
  if (body.type !== 'singularity' || !body.innerSpace) return;
  
  isDiving = true;
  document.body.classList.add('diving');
  
  // Push current space to stack
  navigationStack.push({
    space: currentSpace,
    cameraZ: camera.targetZ
  });
  
  // Animate camera toward the singularity
  camera.targetX = body.x;
  camera.targetY = body.y;
  camera.targetZ = body.z + 50; // Move very close
  
  setTimeout(() => {
    // Switch to inner space
    currentSpace = body.innerSpace;
    
    // Reset camera inside the new space
    camera.x = 0;
    camera.y = 0;
    camera.z = -800;
    camera.targetX = 0;
    camera.targetY = 0;
    camera.targetZ = -800;
    
    isDiving = false;
    document.body.classList.remove('diving');
    
    updateLocationDisplay();
    updateDepthDisplay();
  }, 1200);
}

function ascend() {
  if (navigationStack.length === 0) return;
  
  isDiving = true;
  document.body.classList.add('diving');
  
  // Zoom out effect
  camera.targetZ = -2000;
  
  setTimeout(() => {
    const prev = navigationStack.pop();
    currentSpace = prev.space;
    
    camera.x = 0;
    camera.y = 0;
    camera.z = -2000;
    camera.targetX = 0;
    camera.targetY = 0;
    camera.targetZ = prev.cameraZ;
    
    isDiving = false;
    document.body.classList.remove('diving');
    
    updateLocationDisplay();
    updateDepthDisplay();
  }, 800);
}

function updateLocationDisplay() {
  const loc = document.getElementById('location');
  if (navigationStack.length === 0) {
    loc.textContent = 'the field';
  } else {
    loc.textContent = currentSpace.name;
  }
}

function updateDepthDisplay() {
  const depthEl = document.getElementById('depth');
  
  if (navigationStack.length === 0) {
    depthEl.innerHTML = '';
    return;
  }
  
  let html = '<span class="depth-crumb" onclick="navigateToDepth(0)">field</span>';
  
  navigationStack.forEach((item, i) => {
    html += '<span class="depth-separator">›</span>';
    const isCurrent = i === navigationStack.length - 1;
    html += `<span class="depth-crumb ${isCurrent ? '' : ''}" onclick="navigateToDepth(${i + 1})">${navigationStack[i].space === currentSpace ? currentSpace.name : '...'}</span>`;
  });
  
  // Current space
  html += '<span class="depth-separator">›</span>';
  html += `<span class="depth-crumb current">${currentSpace.name}</span>`;
  
  depthEl.innerHTML = html;
}

window.navigateToDepth = function(depth) {
  while (navigationStack.length > depth) {
    ascend();
  }
};

// === INPUT ===
document.addEventListener('click', e => {
  if (viewerOpen) {
    closeViewer();
    return;
  }
  
  if (isDiving) return;
  
  if (targetedBody) {
    if (targetedBody.type === 'singularity' && targetedBody.innerSpace) {
      diveInto(targetedBody);
    } else {
      openViewer(targetedBody);
    }
  }
});

document.addEventListener('keydown', e => {
  if (viewerOpen) {
    if (e.key === 'Escape') closeViewer();
    return;
  }
  
  if (e.key === 'Escape') {
    if (isInvoking) {
      closeInvoke();
    } else if (navigationStack.length > 0) {
      ascend();
    }
    return;
  }
  
  if (e.key === 'Backspace' && !isInvoking) {
    if (navigationStack.length > 0) ascend();
    return;
  }
  
  // Movement
  const moveSpeed = 20;
  if (e.key === 'w' || e.key === 'ArrowUp') {
    camera.targetZ += moveSpeed;
  } else if (e.key === 's' || e.key === 'ArrowDown') {
    camera.targetZ -= moveSpeed;
  } else if (e.key === 'a' || e.key === 'ArrowLeft') {
    camera.targetX -= moveSpeed;
  } else if (e.key === 'd' || e.key === 'ArrowRight') {
    camera.targetX += moveSpeed;
  }
  
  // Invoke on any letter
  if (e.key.length === 1 && !e.ctrlKey && !e.metaKey && !isInvoking) {
    openInvoke(e.key);
    e.preventDefault();
  }
});

// Mouse wheel for zoom
document.addEventListener('wheel', e => {
  if (viewerOpen) return;
  camera.targetZ += e.deltaY * 0.5;
  camera.targetZ = Math.max(-2000, Math.min(500, camera.targetZ));
});

// === INVOKE ===
function openInvoke(initial = '') {
  isInvoking = true;
  const invoke = document.getElementById('invoke');
  const input = document.getElementById('invokeInput');
  invoke.classList.add('active');
  input.value = initial;
  input.focus();
}

function closeInvoke() {
  isInvoking = false;
  document.getElementById('invoke').classList.remove('active');
  document.getElementById('invokeInput').value = '';
}

document.getElementById('invokeInput').addEventListener('keydown', e => {
  if (e.key === 'Enter') {
    const query = e.target.value.trim();
    handleInvoke(query);
    closeInvoke();
  } else if (e.key === 'Escape') {
    closeInvoke();
  }
});

function handleInvoke(query) {
  if (!query) return;
  
  const lower = query.toLowerCase();
  
  if (lower.startsWith('new ') || lower === 'new') {
    const name = query.slice(4).trim() || 'Untitled';
    createCollection(name);
    return;
  }
  
  // Search for matching body
  const match = currentSpace.bodies.find(b => 
    b.name.toLowerCase().includes(lower)
  );
  
  if (match) {
    // Move camera toward it
    camera.targetX = match.x;
    camera.targetY = match.y;
    camera.targetZ = match.z - 200;
  } else {
    showMessage('nothing found');
  }
}

// === VIEWER ===
async function openViewer(body) {
  viewerOpen = true;
  
  const viewer = document.getElementById('viewer');
  const content = document.getElementById('viewerContent');
  
  content.innerHTML = '<p style="color: rgba(255,255,255,0.3); font-style: italic;">surfacing...</p>';
  viewer.classList.add('open');
  
  try {
    const docContent = await fetchDocContent(body.data.source);
    content.innerHTML = marked.parse(docContent);
    styleViewerContent();
  } catch (err) {
    content.innerHTML = '<p style="color: rgba(200,150,120,0.8);">could not surface</p>';
  }
}

function closeViewer() {
  viewerOpen = false;
  document.getElementById('viewer').classList.remove('open');
}

function styleViewerContent() {
  const container = document.getElementById('viewerContent');
  container.querySelectorAll('td').forEach(td => {
    const text = td.textContent.trim().toLowerCase();
    if (text === 'complete') td.classList.add('status-complete');
    else if (text === 'incomplete') td.classList.add('status-incomplete');
  });
}

// === DRAG & DROP ===
let dragCount = 0;

document.addEventListener('dragenter', e => {
  e.preventDefault();
  dragCount++;
  document.body.classList.add('dropping');
});

document.addEventListener('dragleave', e => {
  e.preventDefault();
  dragCount--;
  if (dragCount === 0) document.body.classList.remove('dropping');
});

document.addEventListener('dragover', e => e.preventDefault());

document.addEventListener('drop', e => {
  e.preventDefault();
  dragCount = 0;
  document.body.classList.remove('dropping');
  
  const files = Array.from(e.dataTransfer.files);
  if (files.length) processFiles(files);
});

// === API ===
async function api(endpoint, options = {}) {
  const res = await fetch(`${CONFIG.API_BASE}${endpoint}`, {
    headers: { 
      'Authorization': `Bearer ${CONFIG.API_KEY}`, 
      'Content-Type': 'application/json',
      ...options.headers 
    },
    ...options
  });
  if (!res.ok) throw new Error(`API ${res.status}`);
  if (res.status === 204) return null;
  const text = await res.text();
  return text ? JSON.parse(text) : null;
}

async function getAuthToken() {
  const res = await fetch(`${CONFIG.AUTH_BASE}/auth/token?token=${CONFIG.API_KEY}`, {
    headers: { 'Authorization': `Bearer ${CONFIG.API_KEY}` }
  });
  if (!res.ok) throw new Error('Auth failed');
  return (await res.json()).token;
}

async function loadCollections() {
  const data = await api('/collections/search', {
    method: 'POST',
    body: JSON.stringify({ dynamic: false, status: 'active', limit: 100 })
  });
  collections = data || [];
}

async function loadDocuments() {
  const data = await api('/objects?limit=1000&offset=0');
  documents = (Array.isArray(data) ? data : data?.objects || [])
    .filter(o => o.content?.source)
    .map(o => ({
      id: o.id,
      name: o.name || 'Untitled',
      type: o.properties?.document_type || '',
      created_at: o.created_at,
      source: o.content?.source
    }));
}

async function loadCollectionMembersData(colId) {
  if (collectionMembers[colId]) return collectionMembers[colId];
  const members = await api(`/collections/${colId}/members?limit=1000`);
  collectionMembers[colId] = (members || []).map(m => m.id || m);
  return collectionMembers[colId];
}

async function fetchDocContent(source) {
  const { url } = await api('/objects/download-url', {
    method: 'POST',
    body: JSON.stringify({ file: source, format: 'original' })
  });
  const res = await fetch(url);
  return await res.text();
}

async function createCollection(name) {
  try {
    showMessage('forming...');
    const jwt = await getAuthToken();
    const res = await fetch(`${CONFIG.API_BASE}/collections`, {
      method: 'POST',
      headers: { 'Authorization': `Bearer ${jwt}`, 'Content-Type': 'application/json' },
      body: JSON.stringify({ name, description: '', dynamic: false })
    });
    
    if (res.ok) {
      const col = await res.json();
      collections.push(col);
      
      // Create singularity in current space
      const body = new Body(col, 'singularity');
      body.x = (Math.random() - 0.5) * 400;
      body.y = (Math.random() - 0.5) * 300;
      body.z = (Math.random() - 0.5) * 200;
      
      // Create inner space
      body.innerSpace = new Space(col.id, col.name, currentSpace);
      
      currentSpace.addBody(body);
      showMessage(`"${name}" emerges`);
    }
  } catch (err) {
    showMessage('could not form');
  }
}

async function processFiles(files) {
  for (const file of files) {
    await processFile(file);
  }
}

async function processFile(file) {
  showMessage(`receiving ${file.name}...`);
  
  const mimeType = file.type || 'application/octet-stream';
  
  try {
    const jwt = await getAuthToken();
    
    const uploadRes = await api('/objects/upload-url', {
      method: 'POST',
      body: JSON.stringify({ name: file.name, mime_type: mimeType })
    });
    
    await fetch(uploadRes.url, {
      method: 'PUT',
      headers: { 'Content-Type': mimeType },
      body: file
    });
    
    const createRes = await fetch(`${CONFIG.API_BASE}/objects`, {
      method: 'POST',
      headers: { 'Authorization': `Bearer ${jwt}`, 'Content-Type': 'application/json' },
      body: JSON.stringify({
        name: file.name,
        content: { source: uploadRes.id, type: mimeType, name: file.name }
      })
    });
    
    const obj = await createRes.json();
    
    const doc = {
      id: obj.id,
      name: file.name,
      type: '',
      created_at: new Date().toISOString(),
      source: uploadRes.id
    };
    documents.push(doc);
    
    // Create star in current space
    const body = new Body(doc, 'star');
    body.x = (Math.random() - 0.5) * 500;
    body.y = (Math.random() - 0.5) * 400;
    body.z = (Math.random() - 0.5) * 300 + 200; // Spawn in front
    
    currentSpace.addBody(body);
    
    // Process with agent
    let targetCollection = 'NEW';
    // If we're inside a collection, use that as target
    if (navigationStack.length > 0) {
      targetCollection = currentSpace.id;
    }
    
    await fetch(`${CONFIG.API_BASE}/execute/async`, {
      method: 'POST',
      headers: { 'Authorization': `Bearer ${jwt}`, 'Content-Type': 'application/json' },
      body: JSON.stringify({
        type: 'conversation',
        interaction: CONFIG.INTERACTION,
        data: { task: obj.id, target_collection: targetCollection },
        config: {
          environment: '681915c6a01fb262a410c161',
          model: 'publishers/anthropic/models/claude-sonnet-4'
        },
        interactive: true,
        max_iterations: 100
      })
    });
    
    showMessage(`${file.name} surfaces`);
    
  } catch (err) {
    console.error(err);
    showMessage('could not receive');
  }
}

// === BUILD UNIVERSE ===
async function buildUniverse() {
  // Create root space (the field)
  const rootSpace = new Space('root', 'the field', null);
  spaces.push(rootSpace);
  currentSpace = rootSpace;
  
  // Create singularities for each collection
  for (const col of collections) {
    const body = new Body(col, 'singularity');
    
    // Distribute in 3D space
    const angle = Math.random() * Math.PI * 2;
    const radius = 200 + Math.random() * 200;
    body.x = Math.cos(angle) * radius;
    body.y = (Math.random() - 0.5) * 300;
    body.z = Math.sin(angle) * radius;
    
    // Create inner space for this collection
    body.innerSpace = new Space(col.id, col.name, rootSpace);
    spaces.push(body.innerSpace);
    
    // Load members and populate inner space
    try {
      const memberIds = await loadCollectionMembersData(col.id);
      const memberDocs = documents.filter(d => memberIds.includes(d.id));
      
      memberDocs.forEach((doc, i) => {
        const star = new Body(doc, 'star');
        
        // Orbit around center of inner space
        const orbitRadius = 100 + i * 40 + Math.random() * 50;
        star.setOrbit(0, 0, 0, orbitRadius);
        star.orbitAngle = (i / memberDocs.length) * Math.PI * 2;
        
        body.innerSpace.addBody(star);
      });
    } catch (err) {
      console.error('Failed to load members for', col.name);
    }
    
    rootSpace.addBody(body);
  }
  
  // Add orphan documents (not in any collection) as distant stars
  const assignedDocIds = new Set(Object.values(collectionMembers).flat());
  const orphanDocs = documents.filter(d => !assignedDocIds.has(d.id));
  
  orphanDocs.forEach((doc, i) => {
    const body = new Body(doc, 'star');
    const angle = (i / orphanDocs.length) * Math.PI * 2;
    const radius = 500 + Math.random() * 200;
    body.x = Math.cos(angle) * radius;
    body.y = (Math.random() - 0.5) * 400;
    body.z = Math.sin(angle) * radius;
    rootSpace.addBody(body);
  });
}

function showMessage(text) {
  const msg = document.getElementById('message');
  msg.textContent = text;
  msg.classList.add('visible');
  setTimeout(() => msg.classList.remove('visible'), 2500);
}

// === INIT ===
async function init() {
  try {
    await loadCollections();
    await loadDocuments();
    await buildUniverse();
    
    updateLocationDisplay();
    updateDepthDisplay();
  } catch (err) {
    console.error('Init failed:', err);
    showMessage('could not connect');
  }
  
  setTimeout(() => {
    document.getElementById('loading').classList.add('hidden');
  }, 800);
  
  requestAnimationFrame(animate);
}

init();
</script>
</body>
</html>
