<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Â·</title>
  <link rel="icon" type="image/svg+xml" href="data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 32 32'%3E%3Ccircle cx='16' cy='16' r='4' fill='%23888'/%3E%3C/svg%3E">
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=Cormorant:ital,wght@0,300;1,300&display=swap" rel="stylesheet">
  <script src="https://cdn.jsdelivr.net/npm/marked/marked.min.js"></script>
  <style>
    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }
    
    html, body {
      height: 100%;
      overflow: hidden;
      background: #000;
      cursor: none;
    }
    
    /* Custom cursor - presence indicator */
    .presence {
      position: fixed;
      width: 80px;
      height: 80px;
      border: 1px solid rgba(255,255,255,0.1);
      border-radius: 50%;
      pointer-events: none;
      transform: translate(-50%, -50%);
      transition: 
        width 0.4s cubic-bezier(0.16, 1, 0.3, 1),
        height 0.4s cubic-bezier(0.16, 1, 0.3, 1),
        border-color 0.3s ease;
      z-index: 1000;
    }
    
    .presence::after {
      content: '';
      position: absolute;
      top: 50%;
      left: 50%;
      width: 4px;
      height: 4px;
      background: rgba(255,255,255,0.6);
      border-radius: 50%;
      transform: translate(-50%, -50%);
    }
    
    .presence.hovering {
      width: 120px;
      height: 120px;
      border-color: rgba(255,255,255,0.3);
    }
    
    .presence.focused {
      width: 200px;
      height: 200px;
      border-color: rgba(140, 200, 200, 0.4);
    }
    
    /* The canvas */
    canvas {
      position: fixed;
      top: 0;
      left: 0;
    }
    
    /* Whisper - minimal text that appears */
    .whisper {
      position: fixed;
      font-family: 'Cormorant', Georgia, serif;
      font-size: 14px;
      font-weight: 300;
      font-style: italic;
      color: rgba(255,255,255,0.4);
      pointer-events: none;
      opacity: 0;
      transition: opacity 0.5s ease;
      z-index: 100;
      max-width: 200px;
      text-align: center;
      transform: translate(-50%, -50%);
    }
    
    .whisper.visible {
      opacity: 1;
    }
    
    /* The deep view - when entering a document */
    .deep {
      position: fixed;
      inset: 0;
      background: #000;
      z-index: 500;
      opacity: 0;
      pointer-events: none;
      transition: opacity 0.8s cubic-bezier(0.16, 1, 0.3, 1);
      display: flex;
      align-items: center;
      justify-content: center;
      overflow: hidden;
    }
    
    .deep.open {
      opacity: 1;
      pointer-events: all;
    }
    
    .deep-content {
      max-width: 680px;
      max-height: 80vh;
      padding: 60px;
      overflow-y: auto;
      font-family: 'Cormorant', Georgia, serif;
      color: rgba(255,255,255,0.8);
      opacity: 0;
      transform: scale(0.95);
      transition: all 0.6s cubic-bezier(0.16, 1, 0.3, 1) 0.2s;
    }
    
    .deep.open .deep-content {
      opacity: 1;
      transform: scale(1);
    }
    
    .deep-content::-webkit-scrollbar {
      width: 2px;
    }
    
    .deep-content::-webkit-scrollbar-thumb {
      background: rgba(255,255,255,0.2);
    }
    
    .deep-content h1 {
      font-size: 32px;
      font-weight: 300;
      margin-bottom: 40px;
      color: rgba(255,255,255,0.9);
      letter-spacing: 0.02em;
    }
    
    .deep-content h2 {
      font-size: 20px;
      font-weight: 300;
      margin: 40px 0 20px;
      color: rgba(255,255,255,0.7);
    }
    
    .deep-content p {
      font-size: 18px;
      line-height: 1.9;
      margin-bottom: 20px;
      color: rgba(255,255,255,0.6);
    }
    
    .deep-content ul, .deep-content ol {
      margin: 20px 0;
      padding-left: 24px;
    }
    
    .deep-content li {
      font-size: 18px;
      line-height: 1.8;
      margin-bottom: 8px;
      color: rgba(255,255,255,0.6);
    }
    
    .deep-content table {
      width: 100%;
      border-collapse: collapse;
      margin: 30px 0;
    }
    
    .deep-content th {
      font-size: 11px;
      font-weight: 300;
      letter-spacing: 0.15em;
      text-transform: uppercase;
      color: rgba(255,255,255,0.4);
      padding: 12px 16px;
      text-align: left;
      border-bottom: 1px solid rgba(255,255,255,0.1);
    }
    
    .deep-content td {
      font-size: 15px;
      padding: 12px 16px;
      color: rgba(255,255,255,0.6);
      border-bottom: 1px solid rgba(255,255,255,0.05);
    }
    
    .deep-content .complete { color: rgba(140, 200, 160, 0.9); }
    .deep-content .incomplete { color: rgba(200, 140, 140, 0.9); }
    .deep-content .partial { color: rgba(200, 180, 140, 0.9); }
    
    .deep-escape {
      position: fixed;
      bottom: 40px;
      left: 50%;
      transform: translateX(-50%);
      font-family: 'Cormorant', Georgia, serif;
      font-size: 12px;
      font-style: italic;
      color: rgba(255,255,255,0.3);
      letter-spacing: 0.1em;
    }
    
    /* Input - appears at bottom when you start typing */
    .invoke {
      position: fixed;
      bottom: 40px;
      left: 50%;
      transform: translateX(-50%);
      z-index: 200;
      opacity: 0;
      transition: opacity 0.3s ease;
      pointer-events: none;
    }
    
    .invoke.active {
      opacity: 1;
      pointer-events: all;
    }
    
    .invoke input {
      width: 400px;
      padding: 16px 24px;
      background: rgba(255,255,255,0.03);
      border: 1px solid rgba(255,255,255,0.1);
      border-radius: 30px;
      font-family: 'Cormorant', Georgia, serif;
      font-size: 16px;
      font-style: italic;
      color: rgba(255,255,255,0.8);
      outline: none;
      text-align: center;
    }
    
    .invoke input::placeholder {
      color: rgba(255,255,255,0.3);
    }
    
    /* Ambient hint */
    .hint {
      position: fixed;
      bottom: 40px;
      left: 50%;
      transform: translateX(-50%);
      font-family: 'Cormorant', Georgia, serif;
      font-size: 13px;
      font-style: italic;
      color: rgba(255,255,255,0.15);
      letter-spacing: 0.05em;
      z-index: 50;
      transition: opacity 0.5s ease;
    }
    
    .hint.hidden {
      opacity: 0;
    }
    
    /* Drop zone - subtle */
    .drop-active::before {
      content: '';
      position: fixed;
      inset: 0;
      background: radial-gradient(circle at center, rgba(140, 200, 200, 0.05) 0%, transparent 70%);
      pointer-events: none;
      z-index: 400;
      animation: dropPulse 1.5s ease infinite;
    }
    
    @keyframes dropPulse {
      0%, 100% { opacity: 0.5; }
      50% { opacity: 1; }
    }
    
    .drop-active .hint {
      color: rgba(140, 200, 200, 0.4);
    }
    
    .drop-active .hint::after {
      content: 'release to offer';
    }
    
    /* Loading */
    .loading {
      position: fixed;
      inset: 0;
      background: #000;
      display: flex;
      align-items: center;
      justify-content: center;
      z-index: 1000;
      transition: opacity 1s ease;
    }
    
    .loading.hidden {
      opacity: 0;
      pointer-events: none;
    }
    
    .loading-dot {
      width: 8px;
      height: 8px;
      background: rgba(255,255,255,0.5);
      border-radius: 50%;
      animation: breathe 2s ease infinite;
    }
    
    @keyframes breathe {
      0%, 100% { opacity: 0.2; transform: scale(1); }
      50% { opacity: 0.8; transform: scale(1.5); }
    }
    
    /* Toast - minimal */
    .message {
      position: fixed;
      top: 40px;
      left: 50%;
      transform: translateX(-50%);
      font-family: 'Cormorant', Georgia, serif;
      font-size: 14px;
      font-style: italic;
      color: rgba(255,255,255,0.5);
      z-index: 600;
      opacity: 0;
      transition: opacity 0.5s ease;
    }
    
    .message.visible {
      opacity: 1;
    }
  </style>
</head>
<body>
  <div class="loading" id="loading">
    <div class="loading-dot"></div>
  </div>
  
  <div class="presence" id="presence"></div>
  <canvas id="field"></canvas>
  
  <div class="whisper" id="whisper"></div>
  
  <div class="hint" id="hint">attend</div>
  
  <div class="invoke" id="invoke">
    <input type="text" id="invokeInput" placeholder="speak" autocomplete="off">
  </div>
  
  <div class="deep" id="deep">
    <div class="deep-content" id="deepContent"></div>
    <div class="deep-escape">press anywhere to return</div>
  </div>
  
  <div class="message" id="message"></div>
  
  <input type="file" id="fileInput" multiple accept=".pdf,.docx,.doc,.txt,.png,.jpg,.jpeg,.xlsx,.xls,.csv,.md" style="display:none">

<script>
// === CONFIG ===
const CONFIG = {
  API_BASE: 'https://api.vertesia.io/api/v1',
  AUTH_BASE: 'https://api.vertesia.io',
  API_KEY: 'sk-cf3c2d29bc38bfee2ae95bf107cb9046',
  INTERACTION: 'PathB'
};

// === STATE ===
let particles = [];
let mouse = { x: window.innerWidth / 2, y: window.innerHeight / 2 };
let collections = [];
let documents = [];
let collectionMembers = {};
let hoveredParticle = null;
let selectedParticle = null;
let isDeepOpen = false;
let isInvokeOpen = false;

// === PARTICLE CLASS ===
class Particle {
  constructor(data, type) {
    this.id = data.id;
    this.name = data.name;
    this.type = type; // 'collection' or 'document'
    this.data = data;
    
    // Position - start from center
    const cx = window.innerWidth / 2;
    const cy = window.innerHeight / 2;
    this.x = cx + (Math.random() - 0.5) * 100;
    this.y = cy + (Math.random() - 0.5) * 100;
    
    // Target position (will be calculated)
    this.tx = this.x;
    this.ty = this.y;
    
    // Velocity
    this.vx = 0;
    this.vy = 0;
    
    // Visual properties from metadata
    this.baseSize = type === 'collection' ? 6 : 3;
    this.size = this.baseSize;
    
    // Age affects opacity
    const created = new Date(data.created_at || Date.now());
    const age = (Date.now() - created) / (1000 * 60 * 60 * 24); // days
    this.age = age;
    this.baseAlpha = Math.max(0.3, 1 - (age / 365)); // fade over a year
    this.alpha = this.baseAlpha;
    
    // Type affects color
    if (type === 'collection') {
      this.hue = 180; // teal
      this.saturation = 30;
    } else {
      // Documents vary by type
      const docType = data.type?.toLowerCase() || '';
      if (docType.includes('checklist')) {
        this.hue = 160; // green-ish
        this.saturation = 40;
      } else if (docType.includes('contract') || docType.includes('legal')) {
        this.hue = 200; // blue-ish
        this.saturation = 25;
      } else {
        this.hue = 40; // warm neutral
        this.saturation = 15;
      }
    }
    
    // Breathing offset
    this.breatheOffset = Math.random() * Math.PI * 2;
    this.breatheSpeed = 0.5 + Math.random() * 0.5;
    
    // Drift
    this.driftAngle = Math.random() * Math.PI * 2;
    this.driftSpeed = 0.1 + Math.random() * 0.2;
    
    // For collections - members
    this.members = [];
    
    // Parent collection (for documents)
    this.parentId = null;
  }
  
  update(time) {
    // Breathing
    const breathe = Math.sin(time * this.breatheSpeed + this.breatheOffset);
    this.size = this.baseSize + breathe * (this.baseSize * 0.2);
    
    // Drift
    this.driftAngle += 0.001;
    const driftX = Math.cos(this.driftAngle) * this.driftSpeed;
    const driftY = Math.sin(this.driftAngle) * this.driftSpeed;
    
    // Attraction to cursor (attention field)
    const dx = mouse.x - this.x;
    const dy = mouse.y - this.y;
    const dist = Math.sqrt(dx * dx + dy * dy);
    
    // Particles within attention radius are drawn toward cursor
    const attentionRadius = 200;
    if (dist < attentionRadius && dist > 0) {
      const force = (1 - dist / attentionRadius) * 0.3;
      this.vx += (dx / dist) * force;
      this.vy += (dy / dist) * force;
      
      // Brighten when attended
      this.alpha = Math.min(1, this.baseAlpha + (1 - dist / attentionRadius) * 0.5);
    } else {
      // Return to base alpha
      this.alpha += (this.baseAlpha - this.alpha) * 0.05;
    }
    
    // Gravity toward parent (for documents in collections)
    if (this.parentId && this.type === 'document') {
      const parent = particles.find(p => p.id === this.parentId);
      if (parent) {
        const pdx = parent.x - this.x;
        const pdy = parent.y - this.y;
        const pdist = Math.sqrt(pdx * pdx + pdy * pdy);
        if (pdist > 50) {
          this.vx += (pdx / pdist) * 0.1;
          this.vy += (pdy / pdist) * 0.1;
        }
      }
    }
    
    // Move toward target with easing
    this.vx += (this.tx - this.x) * 0.01;
    this.vy += (this.ty - this.y) * 0.01;
    
    // Add drift
    this.vx += driftX * 0.1;
    this.vy += driftY * 0.1;
    
    // Friction
    this.vx *= 0.95;
    this.vy *= 0.95;
    
    // Apply velocity
    this.x += this.vx;
    this.y += this.vy;
    
    // Bounds (soft)
    const margin = 100;
    if (this.x < margin) this.vx += 0.5;
    if (this.x > window.innerWidth - margin) this.vx -= 0.5;
    if (this.y < margin) this.vy += 0.5;
    if (this.y > window.innerHeight - margin) this.vy -= 0.5;
  }
  
  draw(ctx) {
    // Glow
    const gradient = ctx.createRadialGradient(
      this.x, this.y, 0,
      this.x, this.y, this.size * 4
    );
    gradient.addColorStop(0, `hsla(${this.hue}, ${this.saturation}%, 70%, ${this.alpha * 0.3})`);
    gradient.addColorStop(1, 'transparent');
    ctx.fillStyle = gradient;
    ctx.beginPath();
    ctx.arc(this.x, this.y, this.size * 4, 0, Math.PI * 2);
    ctx.fill();
    
    // Core
    ctx.fillStyle = `hsla(${this.hue}, ${this.saturation}%, 80%, ${this.alpha})`;
    ctx.beginPath();
    ctx.arc(this.x, this.y, this.size, 0, Math.PI * 2);
    ctx.fill();
  }
  
  containsPoint(x, y) {
    const dx = x - this.x;
    const dy = y - this.y;
    const dist = Math.sqrt(dx * dx + dy * dy);
    return dist < Math.max(20, this.size * 3);
  }
}

// === CANVAS ===
const canvas = document.getElementById('field');
const ctx = canvas.getContext('2d');

function resize() {
  canvas.width = window.innerWidth;
  canvas.height = window.innerHeight;
  distributeParticles();
}

window.addEventListener('resize', resize);

// === ANIMATION ===
let animationTime = 0;

function animate() {
  animationTime += 0.016;
  
  // Clear with fade (creates trails)
  ctx.fillStyle = 'rgba(0, 0, 0, 0.15)';
  ctx.fillRect(0, 0, canvas.width, canvas.height);
  
  // Draw connections between related particles
  ctx.strokeStyle = 'rgba(255, 255, 255, 0.03)';
  ctx.lineWidth = 1;
  particles.forEach(p => {
    if (p.type === 'document' && p.parentId) {
      const parent = particles.find(pp => pp.id === p.parentId);
      if (parent) {
        ctx.beginPath();
        ctx.moveTo(p.x, p.y);
        ctx.lineTo(parent.x, parent.y);
        ctx.stroke();
      }
    }
  });
  
  // Update and draw particles
  particles.forEach(p => {
    p.update(animationTime);
    p.draw(ctx);
  });
  
  // Check hover
  checkHover();
  
  requestAnimationFrame(animate);
}

function checkHover() {
  let found = null;
  
  // Check in reverse (top particles first)
  for (let i = particles.length - 1; i >= 0; i--) {
    if (particles[i].containsPoint(mouse.x, mouse.y)) {
      found = particles[i];
      break;
    }
  }
  
  if (found !== hoveredParticle) {
    hoveredParticle = found;
    updatePresence();
    updateWhisper();
  }
}

function updatePresence() {
  const presence = document.getElementById('presence');
  presence.classList.toggle('hovering', hoveredParticle !== null);
}

function updateWhisper() {
  const whisper = document.getElementById('whisper');
  
  if (hoveredParticle) {
    whisper.textContent = hoveredParticle.name;
    whisper.style.left = hoveredParticle.x + 'px';
    whisper.style.top = (hoveredParticle.y - 60) + 'px';
    whisper.classList.add('visible');
  } else {
    whisper.classList.remove('visible');
  }
}

// === MOUSE ===
document.addEventListener('mousemove', e => {
  mouse.x = e.clientX;
  mouse.y = e.clientY;
  
  const presence = document.getElementById('presence');
  presence.style.left = e.clientX + 'px';
  presence.style.top = e.clientY + 'px';
});

document.addEventListener('click', e => {
  if (isDeepOpen) {
    closeDeep();
    return;
  }
  
  if (hoveredParticle) {
    openParticle(hoveredParticle);
  }
});

// === KEYBOARD ===
document.addEventListener('keydown', e => {
  if (isDeepOpen) {
    if (e.key === 'Escape') closeDeep();
    return;
  }
  
  if (e.key === 'Escape') {
    if (isInvokeOpen) {
      closeInvoke();
    }
    return;
  }
  
  // Any letter/number key opens invoke
  if (!isInvokeOpen && e.key.length === 1 && !e.ctrlKey && !e.metaKey) {
    openInvoke(e.key);
    e.preventDefault();
  }
});

function openInvoke(initialChar = '') {
  isInvokeOpen = true;
  const invoke = document.getElementById('invoke');
  const input = document.getElementById('invokeInput');
  invoke.classList.add('active');
  document.getElementById('hint').classList.add('hidden');
  input.value = initialChar;
  input.focus();
  
  input.onkeydown = e => {
    if (e.key === 'Enter') {
      handleInvoke(input.value);
      closeInvoke();
    } else if (e.key === 'Escape') {
      closeInvoke();
    }
  };
}

function closeInvoke() {
  isInvokeOpen = false;
  const invoke = document.getElementById('invoke');
  const input = document.getElementById('invokeInput');
  invoke.classList.remove('active');
  document.getElementById('hint').classList.remove('hidden');
  input.value = '';
  input.blur();
}

function handleInvoke(text) {
  const lower = text.toLowerCase().trim();
  
  if (!lower) return;
  
  if (lower.includes('new') || lower.includes('create')) {
    createCollection(lower.replace(/new|create|collection/g, '').trim() || 'Untitled');
  } else {
    // Search particles
    const match = particles.find(p => 
      p.name.toLowerCase().includes(lower)
    );
    if (match) {
      // Zoom to particle
      match.tx = window.innerWidth / 2;
      match.ty = window.innerHeight / 2;
      setTimeout(() => openParticle(match), 500);
    } else {
      showMessage('nothing surfaces for "' + lower + '"');
    }
  }
}

// === PARTICLE INTERACTION ===
async function openParticle(particle) {
  selectedParticle = particle;
  isDeepOpen = true;
  
  const presence = document.getElementById('presence');
  presence.classList.add('focused');
  
  const deep = document.getElementById('deep');
  const content = document.getElementById('deepContent');
  
  content.innerHTML = '<p style="color: rgba(255,255,255,0.3); font-style: italic;">surfacing...</p>';
  deep.classList.add('open');
  
  if (particle.type === 'collection') {
    await loadCollectionView(particle);
  } else {
    await loadDocumentView(particle);
  }
  
  presence.classList.remove('focused');
}

async function loadCollectionView(particle) {
  const content = document.getElementById('deepContent');
  
  try {
    // Load members
    const memberIds = await loadCollectionMembers(particle.id);
    const docs = documents.filter(d => memberIds.includes(d.id));
    
    // Find checklist
    let checklistDoc = null;
    for (const doc of docs) {
      if (doc.name.toLowerCase().includes('checklist') || doc.source?.endsWith('.md')) {
        checklistDoc = doc;
        break;
      }
    }
    
    if (checklistDoc) {
      const docContent = await fetchDocContent(checklistDoc.source);
      content.innerHTML = marked.parse(docContent);
      styleContent(content);
    } else {
      content.innerHTML = `
        <h1>${particle.name}</h1>
        <p>${docs.length} documents within this field</p>
        <p style="margin-top: 40px; color: rgba(255,255,255,0.3);">offer documents to generate awareness</p>
      `;
    }
  } catch (err) {
    content.innerHTML = '<p style="color: rgba(200,140,140,0.8);">could not surface</p>';
  }
}

async function loadDocumentView(particle) {
  const content = document.getElementById('deepContent');
  
  try {
    const docContent = await fetchDocContent(particle.data.source);
    content.innerHTML = marked.parse(docContent);
    styleContent(content);
  } catch (err) {
    content.innerHTML = '<p style="color: rgba(200,140,140,0.8);">could not surface</p>';
  }
}

function styleContent(container) {
  container.querySelectorAll('td').forEach(td => {
    const text = td.textContent.trim().toLowerCase();
    if (text === 'complete') td.classList.add('complete');
    else if (text === 'incomplete') td.classList.add('incomplete');
    else if (text === 'partial') td.classList.add('partial');
  });
}

function closeDeep() {
  isDeepOpen = false;
  selectedParticle = null;
  document.getElementById('deep').classList.remove('open');
}

// === DRAG & DROP ===
let dragCounter = 0;

document.addEventListener('dragenter', e => {
  e.preventDefault();
  dragCounter++;
  document.body.classList.add('drop-active');
});

document.addEventListener('dragleave', e => {
  e.preventDefault();
  dragCounter--;
  if (dragCounter === 0) {
    document.body.classList.remove('drop-active');
  }
});

document.addEventListener('dragover', e => {
  e.preventDefault();
});

document.addEventListener('drop', e => {
  e.preventDefault();
  dragCounter = 0;
  document.body.classList.remove('drop-active');
  
  const files = Array.from(e.dataTransfer.files);
  if (files.length) processFiles(files);
});

document.getElementById('fileInput').addEventListener('change', e => {
  const files = Array.from(e.target.files);
  if (files.length) processFiles(files);
  e.target.value = '';
});

// === API ===
async function api(endpoint, options = {}) {
  const res = await fetch(`${CONFIG.API_BASE}${endpoint}`, {
    headers: { 
      'Authorization': `Bearer ${CONFIG.API_KEY}`, 
      'Content-Type': 'application/json',
      ...options.headers 
    },
    ...options
  });
  if (!res.ok) throw new Error(`API ${res.status}`);
  if (res.status === 204) return null;
  const text = await res.text();
  return text ? JSON.parse(text) : null;
}

async function getAuthToken() {
  const res = await fetch(`${CONFIG.AUTH_BASE}/auth/token?token=${CONFIG.API_KEY}`, {
    headers: { 'Authorization': `Bearer ${CONFIG.API_KEY}` }
  });
  if (!res.ok) throw new Error('Auth failed');
  return (await res.json()).token;
}

async function loadCollections() {
  const data = await api('/collections/search', {
    method: 'POST',
    body: JSON.stringify({ dynamic: false, status: 'active', limit: 100 })
  });
  collections = data || [];
}

async function loadDocuments() {
  const data = await api('/objects?limit=1000&offset=0');
  documents = (Array.isArray(data) ? data : data?.objects || [])
    .filter(o => o.content?.source)
    .map(o => ({
      id: o.id,
      name: o.name || 'Untitled',
      type: o.properties?.document_type || 'Document',
      created_at: o.created_at,
      source: o.content?.source
    }));
}

async function loadCollectionMembers(colId) {
  if (collectionMembers[colId]) return collectionMembers[colId];
  const members = await api(`/collections/${colId}/members?limit=1000`);
  collectionMembers[colId] = (members || []).map(m => m.id || m);
  return collectionMembers[colId];
}

async function fetchDocContent(source) {
  const { url } = await api('/objects/download-url', {
    method: 'POST',
    body: JSON.stringify({ file: source, format: 'original' })
  });
  const res = await fetch(url);
  return await res.text();
}

async function createCollection(name) {
  try {
    const jwt = await getAuthToken();
    const res = await fetch(`${CONFIG.API_BASE}/collections`, {
      method: 'POST',
      headers: { 
        'Authorization': `Bearer ${jwt}`, 
        'Content-Type': 'application/json' 
      },
      body: JSON.stringify({ name: name.trim(), description: '', dynamic: false })
    });
    
    if (res.ok) {
      const col = await res.json();
      collections.push(col);
      
      // Add particle
      const p = new Particle(col, 'collection');
      p.tx = window.innerWidth / 2 + (Math.random() - 0.5) * 300;
      p.ty = window.innerHeight / 2 + (Math.random() - 0.5) * 300;
      particles.push(p);
      
      showMessage('"' + name + '" emerges');
    }
  } catch (err) {
    showMessage('could not create');
  }
}

async function processFiles(files) {
  for (const file of files) {
    await processFile(file);
  }
}

async function processFile(file) {
  showMessage('offering ' + file.name + '...');
  
  const mimeType = file.type || getMimeType(file.name);
  
  try {
    const jwt = await getAuthToken();
    
    const uploadRes = await api('/objects/upload-url', {
      method: 'POST',
      body: JSON.stringify({ name: file.name, mime_type: mimeType })
    });
    
    await fetch(uploadRes.url, {
      method: 'PUT',
      headers: { 'Content-Type': mimeType },
      body: file
    });
    
    const createRes = await fetch(`${CONFIG.API_BASE}/objects`, {
      method: 'POST',
      headers: { 
        'Authorization': `Bearer ${jwt}`, 
        'Content-Type': 'application/json' 
      },
      body: JSON.stringify({
        name: file.name,
        content: { source: uploadRes.id, type: mimeType, name: file.name }
      })
    });
    
    const obj = await createRes.json();
    
    // Add to documents
    const doc = {
      id: obj.id,
      name: file.name,
      type: 'Document',
      created_at: new Date().toISOString(),
      source: uploadRes.id
    };
    documents.push(doc);
    
    // Create particle
    const p = new Particle(doc, 'document');
    p.x = mouse.x;
    p.y = mouse.y;
    p.tx = window.innerWidth / 2 + (Math.random() - 0.5) * 400;
    p.ty = window.innerHeight / 2 + (Math.random() - 0.5) * 400;
    particles.push(p);
    
    // Process with agent
    const targetCollection = selectedParticle?.type === 'collection' ? selectedParticle.id : 'NEW';
    
    await fetch(`${CONFIG.API_BASE}/execute/async`, {
      method: 'POST',
      headers: { 
        'Authorization': `Bearer ${jwt}`, 
        'Content-Type': 'application/json' 
      },
      body: JSON.stringify({
        type: 'conversation',
        interaction: CONFIG.INTERACTION,
        data: { task: obj.id, target_collection: targetCollection },
        config: {
          environment: '681915c6a01fb262a410c161',
          model: 'publishers/anthropic/models/claude-sonnet-4'
        },
        interactive: true,
        max_iterations: 100
      })
    });
    
    showMessage(file.name + ' surfaces');
    
  } catch (err) {
    console.error(err);
    showMessage('could not offer ' + file.name);
  }
}

function getMimeType(filename) {
  const ext = filename.split('.').pop().toLowerCase();
  const types = {
    pdf: 'application/pdf',
    docx: 'application/vnd.openxmlformats-officedocument.wordprocessingml.document',
    txt: 'text/plain',
    md: 'text/markdown',
    png: 'image/png',
    jpg: 'image/jpeg',
    jpeg: 'image/jpeg',
    csv: 'text/csv'
  };
  return types[ext] || 'application/octet-stream';
}

// === PARTICLES DISTRIBUTION ===
function distributeParticles() {
  const cx = window.innerWidth / 2;
  const cy = window.innerHeight / 2;
  
  // Collections in inner ring
  const collectionParticles = particles.filter(p => p.type === 'collection');
  const docParticles = particles.filter(p => p.type === 'document');
  
  const innerRadius = Math.min(window.innerWidth, window.innerHeight) * 0.2;
  const outerRadius = Math.min(window.innerWidth, window.innerHeight) * 0.35;
  
  collectionParticles.forEach((p, i) => {
    const angle = (i / collectionParticles.length) * Math.PI * 2 - Math.PI / 2;
    p.tx = cx + Math.cos(angle) * innerRadius + (Math.random() - 0.5) * 50;
    p.ty = cy + Math.sin(angle) * innerRadius + (Math.random() - 0.5) * 50;
  });
  
  docParticles.forEach((p, i) => {
    const angle = (i / docParticles.length) * Math.PI * 2;
    p.tx = cx + Math.cos(angle) * outerRadius + (Math.random() - 0.5) * 100;
    p.ty = cy + Math.sin(angle) * outerRadius + (Math.random() - 0.5) * 100;
  });
}

function buildParticles() {
  particles = [];
  
  // Collections as larger particles
  collections.forEach(col => {
    particles.push(new Particle(col, 'collection'));
  });
  
  // Documents as smaller particles
  documents.forEach(doc => {
    particles.push(new Particle(doc, 'document'));
  });
  
  distributeParticles();
  
  // Link documents to collections
  linkParticles();
}

async function linkParticles() {
  // Load all collection members and link documents
  for (const col of collections) {
    try {
      const memberIds = await loadCollectionMembers(col.id);
      particles.forEach(p => {
        if (p.type === 'document' && memberIds.includes(p.id)) {
          p.parentId = col.id;
        }
      });
    } catch (err) {
      // Ignore errors
    }
  }
}

// === MESSAGES ===
function showMessage(text) {
  const msg = document.getElementById('message');
  msg.textContent = text;
  msg.classList.add('visible');
  setTimeout(() => msg.classList.remove('visible'), 3000);
}

// === INIT ===
async function init() {
  resize();
  
  try {
    await loadCollections();
    await loadDocuments();
    buildParticles();
  } catch (err) {
    console.error('Init failed:', err);
    showMessage('could not connect');
  }
  
  setTimeout(() => {
    document.getElementById('loading').classList.add('hidden');
  }, 800);
  
  animate();
}

init();
</script>
</body>
</html>
