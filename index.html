<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Â·</title>
  <link rel="icon" type="image/svg+xml" href="data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 32 32'%3E%3Ccircle cx='16' cy='16' r='4' fill='%23666'/%3E%3C/svg%3E">
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=Crimson+Pro:ital,wght@0,300;0,400;1,300;1,400&family=JetBrains+Mono:wght@300;400&display=swap" rel="stylesheet">
  <script src="https://cdn.jsdelivr.net/npm/marked/marked.min.js"></script>
  <style>
    :root {
      --void: #050506;
      --deep: #0a0a0c;
      --surface: #12121a;
      
      --light: #e4e2df;
      --light-70: rgba(228, 226, 223, 0.7);
      --light-50: rgba(228, 226, 223, 0.5);
      --light-30: rgba(228, 226, 223, 0.3);
      --light-15: rgba(228, 226, 223, 0.15);
      --light-08: rgba(228, 226, 223, 0.08);
      --light-04: rgba(228, 226, 223, 0.04);
      
      --accent: #6eb5b5;
      --accent-70: rgba(110, 181, 181, 0.7);
      --accent-30: rgba(110, 181, 181, 0.3);
      --accent-15: rgba(110, 181, 181, 0.15);
      --accent-08: rgba(110, 181, 181, 0.08);
      
      --complete: #7ac492;
      --complete-30: rgba(122, 196, 146, 0.3);
      --incomplete: #c49a7a;
      --incomplete-30: rgba(196, 154, 122, 0.3);
      --processing: #9a7ac4;
      --processing-30: rgba(154, 122, 196, 0.3);
      
      --font-serif: 'Crimson Pro', Georgia, serif;
      --font-mono: 'JetBrains Mono', monospace;
      
      --ease: cubic-bezier(0.16, 1, 0.3, 1);
    }
    
    * { margin: 0; padding: 0; box-sizing: border-box; }
    html, body { height: 100%; overflow: hidden; background: var(--void); }
    
    body {
      font-family: var(--font-mono);
      color: var(--light);
      cursor: none;
      user-select: none;
    }
    
    /* === PRESENCE (cursor) === */
    #presence {
      position: fixed;
      pointer-events: none;
      z-index: 1000;
      transform: translate(-50%, -50%);
    }
    
    .presence-ring {
      width: 48px;
      height: 48px;
      border: 1px solid var(--light-15);
      border-radius: 50%;
      transition: all 0.4s var(--ease);
    }
    
    .presence-ring::after {
      content: '';
      position: absolute;
      top: 50%;
      left: 50%;
      width: 3px;
      height: 3px;
      background: var(--light-50);
      border-radius: 50%;
      transform: translate(-50%, -50%);
    }
    
    body.hovering .presence-ring {
      width: 72px;
      height: 72px;
      border-color: var(--light-30);
    }
    
    body.focusing .presence-ring {
      width: 120px;
      height: 120px;
      border-color: var(--accent-30);
    }
    
    body.invoking .presence-ring {
      width: 200px;
      height: 200px;
      border-color: var(--accent-30);
      opacity: 0.5;
    }
    
    /* === CANVAS === */
    #field {
      position: fixed;
      top: 0;
      left: 0;
    }
    
    /* === REVEAL (hover info panel) === */
    #reveal {
      position: fixed;
      pointer-events: none;
      z-index: 100;
      opacity: 0;
      transform: translateY(8px);
      transition: all 0.3s var(--ease);
      text-align: center;
    }
    
    #reveal.visible {
      opacity: 1;
      transform: translateY(0);
    }
    
    .reveal-name {
      font-family: var(--font-serif);
      font-size: 15px;
      font-weight: 400;
      color: var(--light-70);
      margin-bottom: 4px;
      max-width: 200px;
      white-space: nowrap;
      overflow: hidden;
      text-overflow: ellipsis;
    }
    
    .reveal-meta {
      font-size: 10px;
      letter-spacing: 0.08em;
      color: var(--light-30);
    }
    
    .reveal-status {
      display: inline-block;
      width: 6px;
      height: 6px;
      border-radius: 50%;
      margin-right: 6px;
      vertical-align: middle;
    }
    
    .reveal-status.complete { background: var(--complete); }
    .reveal-status.incomplete { background: var(--incomplete); }
    .reveal-status.processing { background: var(--processing); animation: pulse 1s ease infinite; }
    
    @keyframes pulse {
      0%, 100% { opacity: 1; }
      50% { opacity: 0.4; }
    }
    
    /* === INVOKE (search/command) === */
    #invoke {
      position: fixed;
      bottom: 48px;
      left: 50%;
      transform: translateX(-50%);
      z-index: 200;
      display: flex;
      flex-direction: column;
      align-items: center;
      gap: 12px;
    }
    
    #invokeInput {
      width: 320px;
      padding: 14px 24px;
      background: var(--surface);
      border: 1px solid var(--light-08);
      border-radius: 28px;
      font-family: var(--font-serif);
      font-size: 15px;
      font-style: italic;
      color: var(--light);
      text-align: center;
      outline: none;
      opacity: 0;
      transform: translateY(20px);
      transition: all 0.4s var(--ease);
    }
    
    #invokeInput::placeholder {
      color: var(--light-30);
    }
    
    #invokeInput:focus,
    body.invoking #invokeInput {
      opacity: 1;
      transform: translateY(0);
      border-color: var(--accent-30);
    }
    
    #invokeHint {
      font-size: 11px;
      letter-spacing: 0.15em;
      color: var(--light-15);
      transition: all 0.4s var(--ease);
    }
    
    body.invoking #invokeHint {
      opacity: 0;
    }
    
    /* === CONTEXT (ambient info) === */
    #context {
      position: fixed;
      top: 32px;
      left: 50%;
      transform: translateX(-50%);
      font-size: 10px;
      letter-spacing: 0.2em;
      text-transform: uppercase;
      color: var(--light-15);
      display: flex;
      align-items: center;
      gap: 12px;
      z-index: 50;
    }
    
    #contextDot {
      width: 5px;
      height: 5px;
      border-radius: 50%;
      background: var(--accent);
      animation: breathe 3s ease infinite;
    }
    
    @keyframes breathe {
      0%, 100% { opacity: 0.3; }
      50% { opacity: 1; }
    }
    
    #contextDot.offline {
      background: var(--incomplete);
      animation: none;
    }
    
    /* === DEEP VIEW === */
    #deep {
      position: fixed;
      inset: 0;
      background: var(--void);
      z-index: 500;
      display: flex;
      opacity: 0;
      pointer-events: none;
      transition: opacity 0.6s var(--ease);
    }
    
    #deep.open {
      opacity: 1;
      pointer-events: all;
    }
    
    .deep-nav {
      width: 280px;
      border-right: 1px solid var(--light-04);
      padding: 64px 24px 24px;
      display: flex;
      flex-direction: column;
      opacity: 0;
      transform: translateX(-20px);
      transition: all 0.5s var(--ease) 0.1s;
    }
    
    #deep.open .deep-nav {
      opacity: 1;
      transform: translateX(0);
    }
    
    .deep-title {
      font-family: var(--font-serif);
      font-size: 18px;
      font-weight: 400;
      color: var(--light-70);
      margin-bottom: 4px;
    }
    
    .deep-subtitle {
      font-size: 10px;
      letter-spacing: 0.1em;
      color: var(--light-30);
      margin-bottom: 32px;
    }
    
    .deep-section-title {
      font-size: 9px;
      letter-spacing: 0.15em;
      text-transform: uppercase;
      color: var(--light-15);
      margin-bottom: 12px;
    }
    
    .deep-items {
      flex: 1;
      overflow-y: auto;
    }
    
    .deep-items::-webkit-scrollbar { width: 2px; }
    .deep-items::-webkit-scrollbar-thumb { background: var(--light-08); }
    
    .deep-item {
      display: flex;
      align-items: center;
      gap: 10px;
      padding: 10px 12px;
      border-radius: 8px;
      cursor: pointer;
      transition: background 0.2s ease;
    }
    
    .deep-item:hover {
      background: var(--light-04);
    }
    
    .deep-item-dot {
      width: 6px;
      height: 6px;
      border-radius: 50%;
      background: var(--light-15);
      flex-shrink: 0;
    }
    
    .deep-item-name {
      font-size: 12px;
      color: var(--light-50);
      flex: 1;
      white-space: nowrap;
      overflow: hidden;
      text-overflow: ellipsis;
    }
    
    .deep-item.active .deep-item-dot {
      background: var(--accent);
    }
    
    .deep-item.active .deep-item-name {
      color: var(--light-70);
    }
    
    .deep-main {
      flex: 1;
      padding: 64px;
      overflow-y: auto;
    }
    
    .deep-main::-webkit-scrollbar { width: 3px; }
    .deep-main::-webkit-scrollbar-thumb { background: var(--light-08); }
    
    .deep-content {
      max-width: 640px;
      margin: 0 auto;
      opacity: 0;
      transform: translateY(20px);
      transition: all 0.5s var(--ease) 0.2s;
    }
    
    #deep.open .deep-content {
      opacity: 1;
      transform: translateY(0);
    }
    
    .deep-content h1 {
      font-family: var(--font-serif);
      font-size: 28px;
      font-weight: 300;
      color: var(--light);
      margin-bottom: 32px;
      padding-bottom: 16px;
      border-bottom: 1px solid var(--light-08);
    }
    
    .deep-content h2 {
      font-family: var(--font-serif);
      font-size: 18px;
      font-weight: 400;
      color: var(--light-70);
      margin: 32px 0 16px;
    }
    
    .deep-content p {
      font-family: var(--font-serif);
      font-size: 16px;
      line-height: 1.85;
      color: var(--light-50);
      margin-bottom: 16px;
    }
    
    .deep-content ul, .deep-content ol {
      margin: 16px 0;
      padding-left: 20px;
    }
    
    .deep-content li {
      font-family: var(--font-serif);
      font-size: 16px;
      line-height: 1.8;
      color: var(--light-50);
      margin-bottom: 6px;
    }
    
    .deep-content table {
      width: 100%;
      border-collapse: collapse;
      margin: 24px 0;
    }
    
    .deep-content th {
      font-size: 9px;
      font-weight: 400;
      letter-spacing: 0.12em;
      text-transform: uppercase;
      color: var(--light-30);
      padding: 10px 14px;
      text-align: left;
      border-bottom: 1px solid var(--light-08);
    }
    
    .deep-content td {
      font-size: 13px;
      padding: 10px 14px;
      color: var(--light-50);
      border-bottom: 1px solid var(--light-04);
    }
    
    .deep-content .status-complete { color: var(--complete); }
    .deep-content .status-incomplete { color: var(--incomplete); }
    .deep-content .status-partial { color: var(--incomplete-30); }
    
    .deep-close {
      position: fixed;
      top: 24px;
      right: 24px;
      width: 40px;
      height: 40px;
      background: transparent;
      border: 1px solid var(--light-08);
      border-radius: 50%;
      color: var(--light-30);
      cursor: pointer;
      display: flex;
      align-items: center;
      justify-content: center;
      z-index: 510;
      opacity: 0;
      transition: all 0.3s var(--ease) 0.3s;
    }
    
    #deep.open .deep-close {
      opacity: 1;
    }
    
    .deep-close:hover {
      border-color: var(--light-15);
      color: var(--light-50);
    }
    
    /* === DROP ZONE === */
    body.dropping::before {
      content: '';
      position: fixed;
      inset: 0;
      background: radial-gradient(circle at center, var(--accent-08) 0%, transparent 60%);
      z-index: 400;
      pointer-events: none;
      animation: dropGlow 1.5s ease infinite;
    }
    
    @keyframes dropGlow {
      0%, 100% { opacity: 0.5; }
      50% { opacity: 1; }
    }
    
    #dropText {
      position: fixed;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      font-family: var(--font-serif);
      font-size: 16px;
      font-style: italic;
      color: var(--accent-70);
      z-index: 410;
      opacity: 0;
      pointer-events: none;
      transition: opacity 0.3s ease;
    }
    
    body.dropping #dropText {
      opacity: 1;
    }
    
    /* === MESSAGE === */
    #message {
      position: fixed;
      bottom: 120px;
      left: 50%;
      transform: translateX(-50%);
      font-family: var(--font-serif);
      font-size: 13px;
      font-style: italic;
      color: var(--light-30);
      z-index: 150;
      opacity: 0;
      transition: opacity 0.4s ease;
      pointer-events: none;
    }
    
    #message.visible {
      opacity: 1;
    }
    
    /* === LOADING === */
    #loading {
      position: fixed;
      inset: 0;
      background: var(--void);
      display: flex;
      align-items: center;
      justify-content: center;
      z-index: 1000;
      transition: opacity 1s var(--ease);
    }
    
    #loading.hidden {
      opacity: 0;
      pointer-events: none;
    }
    
    .loading-dot {
      width: 6px;
      height: 6px;
      background: var(--light-30);
      border-radius: 50%;
      animation: breathe 2s ease infinite;
    }
    
    /* === EMPTY STATE === */
    #empty {
      position: fixed;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      text-align: center;
      z-index: 10;
      opacity: 0;
      transition: opacity 0.5s ease;
      pointer-events: none;
    }
    
    #empty.visible {
      opacity: 1;
    }
    
    .empty-ring {
      width: 100px;
      height: 100px;
      border: 1px dashed var(--light-08);
      border-radius: 50%;
      margin: 0 auto 24px;
      display: flex;
      align-items: center;
      justify-content: center;
    }
    
    .empty-text {
      font-family: var(--font-serif);
      font-size: 14px;
      font-style: italic;
      color: var(--light-15);
    }
    
    /* File input */
    #fileInput { display: none; }
  </style>
</head>
<body>
  <div id="loading"><div class="loading-dot"></div></div>
  
  <div id="presence"><div class="presence-ring"></div></div>
  
  <canvas id="field"></canvas>
  
  <div id="context">
    <div id="contextDot"></div>
    <span id="contextText">connected</span>
  </div>
  
  <div id="reveal">
    <div class="reveal-name" id="revealName"></div>
    <div class="reveal-meta" id="revealMeta"></div>
  </div>
  
  <div id="invoke">
    <input type="text" id="invokeInput" placeholder="speak" autocomplete="off">
    <div id="invokeHint">begin typing to invoke</div>
  </div>
  
  <div id="empty">
    <div class="empty-ring">
      <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="1" style="color: var(--light-15)">
        <line x1="12" y1="5" x2="12" y2="19"/><line x1="5" y1="12" x2="19" y2="12"/>
      </svg>
    </div>
    <div class="empty-text">drop to begin</div>
  </div>
  
  <div id="deep">
    <button class="deep-close" onclick="closeDeep()">
      <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="1.5">
        <line x1="18" y1="6" x2="6" y2="18"/><line x1="6" y1="6" x2="18" y2="18"/>
      </svg>
    </button>
    <div class="deep-nav">
      <div class="deep-title" id="deepTitle"></div>
      <div class="deep-subtitle" id="deepSubtitle"></div>
      <div class="deep-section-title">Within</div>
      <div class="deep-items" id="deepItems"></div>
    </div>
    <div class="deep-main">
      <div class="deep-content" id="deepContent"></div>
    </div>
  </div>
  
  <div id="dropText">release to offer</div>
  <div id="message"></div>
  <input type="file" id="fileInput" multiple accept=".pdf,.docx,.doc,.txt,.png,.jpg,.jpeg,.xlsx,.xls,.csv,.md">

<script>
// === CONFIG ===
const CONFIG = {
  API_BASE: 'https://api.vertesia.io/api/v1',
  AUTH_BASE: 'https://api.vertesia.io',
  API_KEY: 'sk-cf3c2d29bc38bfee2ae95bf107cb9046',
  INTERACTION: 'PathB'
};

// === STATE ===
let particles = [];
let collections = [];
let documents = [];
let collectionMembers = {};
let mouse = { x: window.innerWidth / 2, y: window.innerHeight / 2 };
let hoveredParticle = null;
let focusedParticle = null;
let selectedParticle = null;
let hoverTime = 0;
let isDeepOpen = false;
let isInvoking = false;
let searchQuery = '';
let currentDeepDoc = null;

// === PARTICLE ===
class Particle {
  constructor(data, type) {
    this.id = data.id;
    this.name = data.name || 'Untitled';
    this.type = type;
    this.data = data;
    
    // Stable home position (calculated once)
    this.homeX = 0;
    this.homeY = 0;
    
    // Current position
    this.x = window.innerWidth / 2;
    this.y = window.innerHeight / 2;
    
    // Velocity
    this.vx = (Math.random() - 0.5) * 2;
    this.vy = (Math.random() - 0.5) * 2;
    
    // Visual properties
    this.baseRadius = type === 'collection' ? 8 : 4;
    this.radius = this.baseRadius;
    
    // State
    this.status = data.status || 'idle'; // idle, complete, incomplete, processing
    this.memberCount = 0;
    
    // Calculate visual properties from metadata
    this.calculateVisuals();
    
    // Animation
    this.phase = Math.random() * Math.PI * 2;
    this.breatheSpeed = 0.3 + Math.random() * 0.4;
    
    // Interaction state
    this.attention = 0; // 0-1, how much attention this particle has
    this.searchMatch = 0; // 0-1, how well it matches current search
    
    // Parent (for documents)
    this.parentId = null;
  }
  
  calculateVisuals() {
    // Age affects base opacity
    const created = new Date(this.data.created_at || Date.now());
    const ageInDays = (Date.now() - created) / (1000 * 60 * 60 * 24);
    this.age = ageInDays;
    this.baseAlpha = Math.max(0.25, 1 - ageInDays / 180); // fade over 6 months
    
    // Color based on type and status
    if (this.type === 'collection') {
      this.hue = 175;
      this.sat = 35;
      this.lit = 55;
    } else {
      const docType = (this.data.type || '').toLowerCase();
      if (docType.includes('checklist') || docType.includes('summary')) {
        this.hue = 150;
        this.sat = 40;
        this.lit = 50;
      } else if (docType.includes('contract') || docType.includes('agreement')) {
        this.hue = 200;
        this.sat = 30;
        this.lit = 50;
      } else if (docType.includes('id') || docType.includes('passport')) {
        this.hue = 40;
        this.sat = 35;
        this.lit = 55;
      } else {
        this.hue = 220;
        this.sat = 15;
        this.lit = 60;
      }
    }
  }
  
  setHome(x, y) {
    this.homeX = x;
    this.homeY = y;
  }
  
  update(time, dt) {
    // Breathing
    const breathe = Math.sin(time * this.breatheSpeed + this.phase);
    
    // Calculate target position
    let targetX = this.homeX;
    let targetY = this.homeY;
    
    // If searching, matching particles move toward center
    if (searchQuery && this.searchMatch > 0) {
      const cx = window.innerWidth / 2;
      const cy = window.innerHeight / 2 - 50;
      targetX = cx + (this.homeX - cx) * (1 - this.searchMatch * 0.7);
      targetY = cy + (this.homeY - cy) * (1 - this.searchMatch * 0.7);
    }
    
    // Parent attraction for documents
    if (this.parentId && this.type === 'document') {
      const parent = particles.find(p => p.id === this.parentId);
      if (parent) {
        // Orbit around parent
        const orbitRadius = 60 + (particles.filter(p => p.parentId === this.parentId).indexOf(this)) * 20;
        const orbitAngle = time * 0.1 + this.phase;
        targetX = parent.x + Math.cos(orbitAngle) * orbitRadius;
        targetY = parent.y + Math.sin(orbitAngle) * orbitRadius;
      }
    }
    
    // Attention attraction (cursor pulls nearby particles gently)
    const dx = mouse.x - this.x;
    const dy = mouse.y - this.y;
    const dist = Math.sqrt(dx * dx + dy * dy);
    const attentionRadius = 150;
    
    if (dist < attentionRadius && dist > 0) {
      this.attention = Math.min(1, this.attention + dt * 2);
      const pull = (1 - dist / attentionRadius) * 0.15 * this.attention;
      this.vx += (dx / dist) * pull;
      this.vy += (dy / dist) * pull;
    } else {
      this.attention = Math.max(0, this.attention - dt * 3);
    }
    
    // Move toward target
    const homeForce = 0.02;
    this.vx += (targetX - this.x) * homeForce;
    this.vy += (targetY - this.y) * homeForce;
    
    // Small drift
    this.vx += Math.sin(time + this.phase) * 0.02;
    this.vy += Math.cos(time * 0.7 + this.phase) * 0.02;
    
    // Damping
    this.vx *= 0.94;
    this.vy *= 0.94;
    
    // Apply velocity
    this.x += this.vx;
    this.y += this.vy;
    
    // Calculate current radius (breathing + attention)
    this.radius = this.baseRadius * (1 + breathe * 0.15 + this.attention * 0.3 + this.searchMatch * 0.5);
    
    // Calculate alpha (base + attention + search)
    this.alpha = this.baseAlpha + this.attention * 0.4 + this.searchMatch * 0.3;
    this.alpha = Math.min(1, this.alpha);
    
    // If not matching search, fade
    if (searchQuery && this.searchMatch === 0) {
      this.alpha *= 0.2;
    }
  }
  
  draw(ctx) {
    // Status ring for collections
    if (this.type === 'collection' && this.status !== 'idle') {
      ctx.beginPath();
      ctx.arc(this.x, this.y, this.radius + 6, 0, Math.PI * 2);
      let ringColor;
      if (this.status === 'complete') ringColor = `rgba(122, 196, 146, ${this.alpha * 0.3})`;
      else if (this.status === 'incomplete') ringColor = `rgba(196, 154, 122, ${this.alpha * 0.3})`;
      else if (this.status === 'processing') ringColor = `rgba(154, 122, 196, ${this.alpha * 0.3})`;
      ctx.strokeStyle = ringColor;
      ctx.lineWidth = 1;
      ctx.stroke();
    }
    
    // Glow
    const glowRadius = this.radius * (3 + this.attention * 2);
    const gradient = ctx.createRadialGradient(
      this.x, this.y, 0,
      this.x, this.y, glowRadius
    );
    gradient.addColorStop(0, `hsla(${this.hue}, ${this.sat}%, ${this.lit}%, ${this.alpha * 0.4})`);
    gradient.addColorStop(1, 'transparent');
    ctx.fillStyle = gradient;
    ctx.beginPath();
    ctx.arc(this.x, this.y, glowRadius, 0, Math.PI * 2);
    ctx.fill();
    
    // Core
    ctx.fillStyle = `hsla(${this.hue}, ${this.sat}%, ${this.lit}%, ${this.alpha})`;
    ctx.beginPath();
    ctx.arc(this.x, this.y, this.radius, 0, Math.PI * 2);
    ctx.fill();
  }
  
  containsPoint(px, py) {
    const dx = px - this.x;
    const dy = py - this.y;
    return Math.sqrt(dx * dx + dy * dy) < Math.max(24, this.radius * 2);
  }
  
  matchesQuery(query) {
    if (!query) return 0;
    const q = query.toLowerCase();
    const name = this.name.toLowerCase();
    if (name === q) return 1;
    if (name.startsWith(q)) return 0.8;
    if (name.includes(q)) return 0.5;
    return 0;
  }
}

// === CANVAS ===
const canvas = document.getElementById('field');
const ctx = canvas.getContext('2d');
let lastTime = performance.now();

function resize() {
  canvas.width = window.innerWidth;
  canvas.height = window.innerHeight;
  calculateLayout();
}

function calculateLayout() {
  const cx = window.innerWidth / 2;
  const cy = window.innerHeight / 2 - 40;
  
  // Collections in a gentle arc/cluster
  const collectionParticles = particles.filter(p => p.type === 'collection');
  const docParticles = particles.filter(p => p.type === 'document' && !p.parentId);
  
  // Collections spread in upper area
  const colRadius = Math.min(300, window.innerWidth * 0.25);
  collectionParticles.forEach((p, i) => {
    const angle = (i / Math.max(1, collectionParticles.length)) * Math.PI - Math.PI / 2;
    const jitter = (Math.random() - 0.5) * 30;
    p.setHome(
      cx + Math.cos(angle) * (colRadius + jitter),
      cy + Math.sin(angle) * (colRadius * 0.6 + jitter) - 50
    );
  });
  
  // Orphan documents in outer ring
  const docRadius = Math.min(400, window.innerWidth * 0.35);
  docParticles.forEach((p, i) => {
    const angle = (i / Math.max(1, docParticles.length)) * Math.PI * 2;
    const jitter = (Math.random() - 0.5) * 50;
    p.setHome(
      cx + Math.cos(angle) * (docRadius + jitter),
      cy + Math.sin(angle) * (docRadius + jitter)
    );
  });
}

window.addEventListener('resize', resize);

// === ANIMATION ===
function animate(currentTime) {
  const dt = Math.min(0.1, (currentTime - lastTime) / 1000);
  lastTime = currentTime;
  const time = currentTime / 1000;
  
  // Clear
  ctx.fillStyle = 'rgba(5, 5, 6, 0.2)';
  ctx.fillRect(0, 0, canvas.width, canvas.height);
  
  // Draw connections (documents to parents)
  ctx.lineWidth = 1;
  particles.forEach(p => {
    if (p.parentId && p.type === 'document') {
      const parent = particles.find(pp => pp.id === p.parentId);
      if (parent) {
        const alpha = Math.min(p.alpha, parent.alpha) * 0.15;
        ctx.strokeStyle = `rgba(228, 226, 223, ${alpha})`;
        ctx.beginPath();
        ctx.moveTo(p.x, p.y);
        ctx.lineTo(parent.x, parent.y);
        ctx.stroke();
      }
    }
  });
  
  // Update and draw particles
  particles.forEach(p => {
    p.searchMatch = p.matchesQuery(searchQuery);
    p.update(time, dt);
    p.draw(ctx);
  });
  
  // Check hover
  updateHover();
  
  requestAnimationFrame(animate);
}

function updateHover() {
  let found = null;
  let closest = Infinity;
  
  particles.forEach(p => {
    if (p.containsPoint(mouse.x, mouse.y)) {
      const dist = Math.sqrt((p.x - mouse.x) ** 2 + (p.y - mouse.y) ** 2);
      if (dist < closest) {
        closest = dist;
        found = p;
      }
    }
  });
  
  if (found !== hoveredParticle) {
    hoveredParticle = found;
    hoverTime = 0;
    updateReveal();
    document.body.classList.toggle('hovering', found !== null);
  } else if (hoveredParticle) {
    hoverTime += 16;
    if (hoverTime > 500 && focusedParticle !== hoveredParticle) {
      focusedParticle = hoveredParticle;
      document.body.classList.add('focusing');
    }
  }
  
  if (!hoveredParticle) {
    focusedParticle = null;
    document.body.classList.remove('focusing');
  }
}

function updateReveal() {
  const reveal = document.getElementById('reveal');
  
  if (hoveredParticle) {
    const p = hoveredParticle;
    document.getElementById('revealName').textContent = p.name;
    
    let meta = '';
    if (p.type === 'collection') {
      const memberCount = collectionMembers[p.id]?.length || 0;
      if (p.status !== 'idle') {
        meta = `<span class="reveal-status ${p.status}"></span>`;
      }
      meta += memberCount + ' within';
    } else {
      const age = Math.floor(p.age);
      meta = age === 0 ? 'today' : age === 1 ? 'yesterday' : age + ' days ago';
    }
    document.getElementById('revealMeta').innerHTML = meta;
    
    reveal.style.left = p.x + 'px';
    reveal.style.top = (p.y - p.radius - 40) + 'px';
    reveal.classList.add('visible');
  } else {
    reveal.classList.remove('visible');
  }
}

// === MOUSE ===
document.addEventListener('mousemove', e => {
  mouse.x = e.clientX;
  mouse.y = e.clientY;
  
  const presence = document.getElementById('presence');
  presence.style.left = e.clientX + 'px';
  presence.style.top = e.clientY + 'px';
});

document.addEventListener('click', e => {
  if (isDeepOpen) {
    // Check if clicking the close button or outside main content
    if (e.target.closest('.deep-close')) {
      closeDeep();
    }
    return;
  }
  
  if (hoveredParticle) {
    openParticle(hoveredParticle);
  } else if (isInvoking) {
    // Don't close invoke on click
  }
});

// === KEYBOARD ===
document.addEventListener('keydown', e => {
  if (isDeepOpen) {
    if (e.key === 'Escape') closeDeep();
    return;
  }
  
  if (e.key === 'Escape') {
    closeInvoke();
    return;
  }
  
  // Any printable character opens invoke
  if (e.key.length === 1 && !e.ctrlKey && !e.metaKey && !e.altKey) {
    openInvoke(e.key);
    e.preventDefault();
  }
});

function openInvoke(initial = '') {
  isInvoking = true;
  document.body.classList.add('invoking');
  
  const input = document.getElementById('invokeInput');
  input.value = initial;
  input.focus();
  
  searchQuery = initial.toLowerCase();
}

function closeInvoke() {
  isInvoking = false;
  document.body.classList.remove('invoking');
  
  const input = document.getElementById('invokeInput');
  input.value = '';
  input.blur();
  
  searchQuery = '';
}

document.getElementById('invokeInput').addEventListener('input', e => {
  searchQuery = e.target.value.toLowerCase();
});

document.getElementById('invokeInput').addEventListener('keydown', e => {
  if (e.key === 'Enter') {
    e.preventDefault();
    const query = e.target.value.trim();
    
    if (!query) {
      closeInvoke();
      return;
    }
    
    // Check for commands
    const lower = query.toLowerCase();
    if (lower.startsWith('new ') || lower === 'new') {
      const name = query.slice(4).trim() || 'Untitled';
      createCollection(name);
      closeInvoke();
      return;
    }
    
    // Find best matching particle
    const matches = particles
      .map(p => ({ p, score: p.matchesQuery(query) }))
      .filter(m => m.score > 0)
      .sort((a, b) => b.score - a.score);
    
    if (matches.length > 0) {
      closeInvoke();
      setTimeout(() => openParticle(matches[0].p), 200);
    } else {
      showMessage('nothing surfaces');
    }
  } else if (e.key === 'Escape') {
    closeInvoke();
  }
});

// === DEEP VIEW ===
async function openParticle(particle) {
  selectedParticle = particle;
  isDeepOpen = true;
  
  const deep = document.getElementById('deep');
  document.getElementById('deepTitle').textContent = particle.name;
  document.getElementById('deepSubtitle').textContent = particle.type === 'collection' ? 'collection' : 'document';
  document.getElementById('deepContent').innerHTML = '<p style="color: var(--light-15); font-style: italic;">surfacing...</p>';
  document.getElementById('deepItems').innerHTML = '';
  
  deep.classList.add('open');
  
  if (particle.type === 'collection') {
    await loadCollectionDeep(particle);
  } else {
    await loadDocumentDeep(particle);
  }
}

async function loadCollectionDeep(particle) {
  try {
    const memberIds = await loadCollectionMembersData(particle.id);
    const docs = documents.filter(d => memberIds.includes(d.id));
    
    // Render sidebar items
    const itemsEl = document.getElementById('deepItems');
    if (docs.length === 0) {
      itemsEl.innerHTML = '<div style="padding: 12px; color: var(--light-15); font-size: 11px; font-style: italic;">nothing within</div>';
    } else {
      itemsEl.innerHTML = docs.map((d, i) => `
        <div class="deep-item ${i === 0 ? 'active' : ''}" data-id="${d.id}" onclick="loadDeepDoc('${d.id}')">
          <div class="deep-item-dot"></div>
          <div class="deep-item-name">${d.name}</div>
        </div>
      `).join('');
    }
    
    // Find and show checklist or first doc
    let primaryDoc = docs.find(d => 
      d.name.toLowerCase().includes('checklist') || 
      d.source?.endsWith('.md')
    ) || docs[0];
    
    if (primaryDoc) {
      await loadDeepDoc(primaryDoc.id);
    } else {
      document.getElementById('deepContent').innerHTML = `
        <h1>${particle.name}</h1>
        <p style="color: var(--light-30);">This field is empty. Drop documents to populate it.</p>
      `;
    }
  } catch (err) {
    document.getElementById('deepContent').innerHTML = '<p style="color: var(--incomplete);">could not surface</p>';
  }
}

async function loadDocumentDeep(particle) {
  document.getElementById('deepItems').innerHTML = '';
  
  try {
    const content = await fetchDocContent(particle.data.source);
    document.getElementById('deepContent').innerHTML = marked.parse(content);
    styleDeepContent();
  } catch (err) {
    document.getElementById('deepContent').innerHTML = '<p style="color: var(--incomplete);">could not surface</p>';
  }
}

window.loadDeepDoc = async function(docId) {
  currentDeepDoc = docId;
  
  // Update active state
  document.querySelectorAll('.deep-item').forEach(el => {
    el.classList.toggle('active', el.dataset.id === docId);
  });
  
  const doc = documents.find(d => d.id === docId);
  if (!doc) return;
  
  try {
    document.getElementById('deepContent').innerHTML = '<p style="color: var(--light-15); font-style: italic;">surfacing...</p>';
    const content = await fetchDocContent(doc.source);
    document.getElementById('deepContent').innerHTML = marked.parse(content);
    styleDeepContent();
  } catch (err) {
    document.getElementById('deepContent').innerHTML = '<p style="color: var(--incomplete);">could not surface</p>';
  }
};

function styleDeepContent() {
  const container = document.getElementById('deepContent');
  container.querySelectorAll('td').forEach(td => {
    const text = td.textContent.trim().toLowerCase();
    if (text === 'complete') td.classList.add('status-complete');
    else if (text === 'incomplete') td.classList.add('status-incomplete');
    else if (text === 'partial') td.classList.add('status-partial');
  });
}

function closeDeep() {
  isDeepOpen = false;
  selectedParticle = null;
  currentDeepDoc = null;
  document.getElementById('deep').classList.remove('open');
}

// === DRAG & DROP ===
let dragCount = 0;

document.addEventListener('dragenter', e => {
  e.preventDefault();
  dragCount++;
  document.body.classList.add('dropping');
});

document.addEventListener('dragleave', e => {
  e.preventDefault();
  dragCount--;
  if (dragCount === 0) {
    document.body.classList.remove('dropping');
  }
});

document.addEventListener('dragover', e => e.preventDefault());

document.addEventListener('drop', e => {
  e.preventDefault();
  dragCount = 0;
  document.body.classList.remove('dropping');
  
  const files = Array.from(e.dataTransfer.files);
  if (files.length) processFiles(files);
});

document.getElementById('fileInput').addEventListener('change', e => {
  const files = Array.from(e.target.files);
  if (files.length) processFiles(files);
  e.target.value = '';
});

// === API ===
async function api(endpoint, options = {}) {
  const res = await fetch(`${CONFIG.API_BASE}${endpoint}`, {
    headers: { 
      'Authorization': `Bearer ${CONFIG.API_KEY}`, 
      'Content-Type': 'application/json',
      ...options.headers 
    },
    ...options
  });
  if (!res.ok) throw new Error(`API ${res.status}`);
  if (res.status === 204) return null;
  const text = await res.text();
  return text ? JSON.parse(text) : null;
}

async function getAuthToken() {
  const res = await fetch(`${CONFIG.AUTH_BASE}/auth/token?token=${CONFIG.API_KEY}`, {
    headers: { 'Authorization': `Bearer ${CONFIG.API_KEY}` }
  });
  if (!res.ok) throw new Error('Auth failed');
  return (await res.json()).token;
}

async function loadCollections() {
  const data = await api('/collections/search', {
    method: 'POST',
    body: JSON.stringify({ dynamic: false, status: 'active', limit: 100 })
  });
  collections = data || [];
}

async function loadDocuments() {
  const data = await api('/objects?limit=1000&offset=0');
  documents = (Array.isArray(data) ? data : data?.objects || [])
    .filter(o => o.content?.source)
    .map(o => ({
      id: o.id,
      name: o.name || 'Untitled',
      type: o.properties?.document_type || '',
      created_at: o.created_at,
      source: o.content?.source,
      status: o.properties?.status || 'idle'
    }));
}

async function loadCollectionMembersData(colId) {
  if (collectionMembers[colId]) return collectionMembers[colId];
  const members = await api(`/collections/${colId}/members?limit=1000`);
  collectionMembers[colId] = (members || []).map(m => m.id || m);
  return collectionMembers[colId];
}

async function fetchDocContent(source) {
  const { url } = await api('/objects/download-url', {
    method: 'POST',
    body: JSON.stringify({ file: source, format: 'original' })
  });
  const res = await fetch(url);
  return await res.text();
}

async function createCollection(name) {
  try {
    showMessage('forming...');
    const jwt = await getAuthToken();
    const res = await fetch(`${CONFIG.API_BASE}/collections`, {
      method: 'POST',
      headers: { 'Authorization': `Bearer ${jwt}`, 'Content-Type': 'application/json' },
      body: JSON.stringify({ name, description: '', dynamic: false })
    });
    
    if (res.ok) {
      const col = await res.json();
      collections.push(col);
      
      const p = new Particle(col, 'collection');
      particles.push(p);
      calculateLayout();
      
      showMessage(`"${name}" emerges`);
      updateEmpty();
    }
  } catch (err) {
    showMessage('could not form');
  }
}

async function processFiles(files) {
  for (const file of files) {
    await processFile(file);
  }
}

async function processFile(file) {
  showMessage(`receiving ${file.name}...`);
  
  const mimeType = file.type || getMimeType(file.name);
  
  try {
    const jwt = await getAuthToken();
    
    const uploadRes = await api('/objects/upload-url', {
      method: 'POST',
      body: JSON.stringify({ name: file.name, mime_type: mimeType })
    });
    
    await fetch(uploadRes.url, {
      method: 'PUT',
      headers: { 'Content-Type': mimeType },
      body: file
    });
    
    const createRes = await fetch(`${CONFIG.API_BASE}/objects`, {
      method: 'POST',
      headers: { 'Authorization': `Bearer ${jwt}`, 'Content-Type': 'application/json' },
      body: JSON.stringify({
        name: file.name,
        content: { source: uploadRes.id, type: mimeType, name: file.name }
      })
    });
    
    const obj = await createRes.json();
    
    const doc = {
      id: obj.id,
      name: file.name,
      type: '',
      created_at: new Date().toISOString(),
      source: uploadRes.id,
      status: 'processing'
    };
    documents.push(doc);
    
    // Create particle at mouse position
    const p = new Particle(doc, 'document');
    p.x = mouse.x;
    p.y = mouse.y;
    p.status = 'processing';
    particles.push(p);
    calculateLayout();
    
    // Send to agent
    const targetCollection = selectedParticle?.type === 'collection' ? selectedParticle.id : 'NEW';
    
    await fetch(`${CONFIG.API_BASE}/execute/async`, {
      method: 'POST',
      headers: { 'Authorization': `Bearer ${jwt}`, 'Content-Type': 'application/json' },
      body: JSON.stringify({
        type: 'conversation',
        interaction: CONFIG.INTERACTION,
        data: { task: obj.id, target_collection: targetCollection },
        config: {
          environment: '681915c6a01fb262a410c161',
          model: 'publishers/anthropic/models/claude-sonnet-4'
        },
        interactive: true,
        max_iterations: 100
      })
    });
    
    // Update particle status after a delay (simulating processing)
    setTimeout(() => {
      p.status = 'idle';
      showMessage(`${file.name} surfaces`);
    }, 2000);
    
    updateEmpty();
    
  } catch (err) {
    console.error(err);
    showMessage(`could not receive ${file.name}`);
  }
}

function getMimeType(filename) {
  const ext = filename.split('.').pop().toLowerCase();
  const types = {
    pdf: 'application/pdf',
    docx: 'application/vnd.openxmlformats-officedocument.wordprocessingml.document',
    txt: 'text/plain',
    md: 'text/markdown',
    png: 'image/png',
    jpg: 'image/jpeg',
    jpeg: 'image/jpeg',
    csv: 'text/csv'
  };
  return types[ext] || 'application/octet-stream';
}

// === HELPERS ===
function showMessage(text) {
  const msg = document.getElementById('message');
  msg.textContent = text;
  msg.classList.add('visible');
  setTimeout(() => msg.classList.remove('visible'), 2500);
}

function updateEmpty() {
  const empty = document.getElementById('empty');
  empty.classList.toggle('visible', particles.length === 0);
}

function buildParticles() {
  particles = [];
  
  collections.forEach(col => {
    const p = new Particle(col, 'collection');
    particles.push(p);
  });
  
  documents.forEach(doc => {
    const p = new Particle(doc, 'document');
    particles.push(p);
  });
  
  calculateLayout();
  linkParticles();
  updateEmpty();
}

async function linkParticles() {
  for (const col of collections) {
    try {
      const memberIds = await loadCollectionMembersData(col.id);
      
      // Update collection status based on members
      const colParticle = particles.find(p => p.id === col.id);
      if (colParticle) {
        colParticle.memberCount = memberIds.length;
        // Could set status based on completeness logic
      }
      
      // Link documents to collections
      particles.forEach(p => {
        if (p.type === 'document' && memberIds.includes(p.id)) {
          p.parentId = col.id;
        }
      });
    } catch (err) {
      // Ignore
    }
  }
  
  calculateLayout();
}

// === INIT ===
async function init() {
  resize();
  
  try {
    await loadCollections();
    await loadDocuments();
    buildParticles();
    
    document.getElementById('contextDot').classList.remove('offline');
    document.getElementById('contextText').textContent = 'connected';
  } catch (err) {
    console.error('Init failed:', err);
    document.getElementById('contextDot').classList.add('offline');
    document.getElementById('contextText').textContent = 'offline';
    showMessage('could not connect');
  }
  
  setTimeout(() => {
    document.getElementById('loading').classList.add('hidden');
  }, 600);
  
  requestAnimationFrame(animate);
}

init();
</script>
</body>
</html>
